/*
 * This file was automatically generated by EvoSuite
 * Fri Aug 10 09:54:02 GMT 2018
 */
package com.tsi.workflow.dao;

import static org.junit.Assert.*;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;

import com.tsi.workflow.DataWareHouse;
import com.tsi.workflow.TestCaseExecutor;
import com.tsi.workflow.TestCaseMockService;
import com.tsi.workflow.User;
import com.tsi.workflow.beans.dao.ImpPlan;
import com.tsi.workflow.beans.dao.Project;
import com.tsi.workflow.beans.dao.System;
import com.tsi.workflow.beans.ui.AdvancedSearchForm;
import com.tsi.workflow.utils.Constants;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.hibernate.Criteria;
import org.hibernate.Query;
import org.hibernate.SQLQuery;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.mockito.Matchers;
import org.mockito.Mockito;
import org.springframework.test.util.ReflectionTestUtils;

public class ImpPlanDAOTest {

    ImpPlanDAO instance;
    ImpPlanDAO mockedInstance;

    public ImpPlanDAOTest() {
    }

    @BeforeClass
    public static void setUpClass() {
    }

    @AfterClass
    public static void tearDownClass() {
    }

    @Before
    public void setUp() {
	try {
	    ImpPlanDAO realInstance = new ImpPlanDAO();
	    instance = spy(realInstance);
	    mockedInstance = mock(ImpPlanDAO.class);
	    TestCaseMockService.doMockBaseDAO(ImpPlanDAO.class, ImpPlan.class, instance);

	} catch (Exception ex) {
	    Logger.getLogger(ImplementationDAOTest.class.getName()).log(Level.SEVERE, null, ex);
	    fail("Fail on Exception " + ex.getMessage());
	}
    }

    @After
    public void tearDown() {
    }

    @Test(timeout = 4000)
    public void test00() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
	List<String> list0 = Locale.filterTags((List<Locale.LanguageRange>) linkedList0, (Collection<String>) null);
	Constants.BUILD_TYPE constants_BUILD_TYPE0 = Constants.BUILD_TYPE.STG_CWS;
	Constants.LoaderTypes constants_LoaderTypes0 = Constants.LoaderTypes.E;
	Integer integer0 = new Integer((-1171));
	LinkedHashMap<String, String> linkedHashMap0 = new LinkedHashMap<String, String>();
	// Undeclared exception!
	try {
	    impPlanDAO0.findQAPlanList(list0, "log4j.loggerFactory", constants_BUILD_TYPE0, constants_LoaderTypes0, (List<String>) null, integer0, integer0, linkedHashMap0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test01() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
	Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.REJECT_EXTENDED_RANGES;
	List<String> list0 = Locale.filterTags((List<Locale.LanguageRange>) linkedList0, (Collection<String>) null, locale_FilteringMode0);
	Integer integer0 = new Integer(1275);
	LinkedHashMap<String, String> linkedHashMap0 = Constants.LoaderTypes.getLoaderTypesList();
	String filter = "T1900111";
	// Undeclared exception!
	try {
	    impPlanDAO0.findByLoad(list0, "oH1M6n/qR$&kWk^%[X", integer0, integer0, (Map<String, String>) linkedHashMap0, filter);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	}
    }

    @Test(timeout = 4000)
    public void test02() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	LinkedList<String> linkedList0 = new LinkedList<String>();
	Integer integer0 = new Integer(2);
	LinkedHashMap<String, String> linkedHashMap0 = new LinkedHashMap<String, String>();
	Integer integer1 = new Integer(2);
	String filter = "";
	// Undeclared exception!
	try {
	    impPlanDAO0.findByLoad((List<String>) linkedList0, "6!@;*FRz+Dr}`6?", integer1, integer0, (Map<String, String>) linkedHashMap0, filter);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    // @Test(timeout = 4000)
    public void test03() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Boolean boolean0 = Boolean.valueOf(" NO");
	Integer integer0 = new Integer(2935);
	Integer integer1 = new Integer(2);
	LinkedHashMap<String, String> linkedHashMap0 = Constants.LoaderTypes.getLoaderTypesList();
	List<ImpPlan> list0 = impPlanDAO0.getPlansByMacroHeader("", "", boolean0, integer0, integer1, linkedHashMap0);
	assertNull(list0);
    }

    @Test(timeout = 4000)
    public void test06() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	LinkedList<String> linkedList0 = new LinkedList<String>();
	Integer integer0 = new Integer((-1154));
	Integer integer1 = new Integer((-1154));
	String filter = "";
	LinkedHashMap<String, String> linkedHashMap0 = new LinkedHashMap<String, String>();
	// Undeclared exception!
	try {
	    impPlanDAO0.findByStatusListAndOwner(linkedList0, "", integer0, integer1, linkedHashMap0, filter);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //
	}
    }

    @Test(timeout = 4000)
    public void test08() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Constants.BUILD_TYPE constants_BUILD_TYPE0 = Constants.BUILD_TYPE.STG_CWS;
	Constants.LoaderTypes constants_LoaderTypes0 = Constants.LoaderTypes.A;
	// Undeclared exception!
	try {
	    impPlanDAO0.countByStatusListUser((List<String>) null, "Mm1F(TWLS-Un\"", false, "", constants_BUILD_TYPE0, constants_LoaderTypes0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test09() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	Constants.BUILD_TYPE constants_BUILD_TYPE0 = Constants.BUILD_TYPE.STG_BUILD;
	Constants.LoaderTypes constants_LoaderTypes0 = Constants.LoaderTypes.A;
	Integer integer0 = new Integer((-1));
	LinkedHashMap<String, String> linkedHashMap0 = new LinkedHashMap<String, String>();
	// Undeclared exception!
	try {
	    impPlanDAO0.findByStatusList((List<String>) null, true, true, "%", "HOMEDIRECTORY", constants_BUILD_TYPE0, constants_LoaderTypes0, (Integer) null, integer0, linkedHashMap0, true);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test10() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	LinkedList<String> linkedList0 = new LinkedList<String>();
	Integer integer0 = new Integer(0);
	LinkedHashMap<String, String> linkedHashMap0 = Constants.LoaderTypes.getLoaderTypesList();
	// Undeclared exception!
	try {
	    impPlanDAO0.findBySO(linkedList0, (List<String>) null, (Date) null, integer0, integer0, linkedHashMap0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test11() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Integer integer0 = new Integer((-1));
	LinkedHashMap<String, String> linkedHashMap0 = new LinkedHashMap<String, String>();
	Integer integer1 = new Integer((-1));
	// Undeclared exception!
	try {
	    impPlanDAO0.findById("", integer1, integer0, linkedHashMap0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //
	}
    }

    @Test(timeout = 4000)
    public void test13() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	try {
	    impPlanDAO0.removePlanDelegate("");
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test14() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	Integer integer0 = new Integer((-1152));
	// Undeclared exception!
	try {
	    impPlanDAO0.getStagingDepedendentPlans(" AND lc.id = lSystemLoads.load_category_id ", integer0, (Date) null);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test15() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	// Undeclared exception!
	try {
	    impPlanDAO0.getPostSegmentRelatedPlansProdLoadFallbackLoad("oH1M6n/qR$&kWk^%[X", Boolean.TRUE);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test17() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	AdvancedSearchForm advancedSearchForm0 = new AdvancedSearchForm();
	List<String> list0 = advancedSearchForm0.getFunctionalPackages();
	// Undeclared exception!
	try {
	    impPlanDAO0.getPostSegmentRelatedPlansBySystem("=9o[1AyJxN0k08kv", " AND lSystem.id IN (:systemId)", list0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test23() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Integer integer0 = new Integer(1250);
	// Undeclared exception!
	try {
	    impPlanDAO0.doPlanAuditForUpdate((String) null, integer0, (Date) null);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test24() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	AdvancedSearchForm advancedSearchForm0 = new AdvancedSearchForm();
	List<String> list0 = advancedSearchForm0.getFunctionalPackages();
	Constants.BUILD_TYPE constants_BUILD_TYPE0 = Constants.BUILD_TYPE.STG_LOAD;
	Constants.LoaderTypes constants_LoaderTypes0 = Constants.LoaderTypes.E;
	Integer integer0 = new Integer(5);
	LinkedHashMap<String, String> linkedHashMap0 = Constants.LoaderTypes.getLoaderTypesList();
	// Undeclared exception!
	try {
	    impPlanDAO0.findQAPlanList((List<String>) null, "The wildcard list must not be null", constants_BUILD_TYPE0, constants_LoaderTypes0, list0, integer0, integer0, linkedHashMap0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test27() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
	Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.REJECT_EXTENDED_RANGES;
	List<String> list0 = Locale.filterTags((List<Locale.LanguageRange>) linkedList0, (Collection<String>) null, locale_FilteringMode0);
	Constants.BUILD_TYPE constants_BUILD_TYPE0 = Constants.BUILD_TYPE.STG_LOAD;
	Constants.LoaderTypes constants_LoaderTypes0 = Constants.LoaderTypes.E;
	// Undeclared exception!
	try {
	    impPlanDAO0.countByStatusListUser(list0, "oH1M6n/qR$&kWk^%[X", true, "oH1M6n/qR$&kWk^%[X", constants_BUILD_TYPE0, constants_LoaderTypes0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test28() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	LinkedList<String> linkedList0 = new LinkedList<String>();
	String filter = "";
	// Undeclared exception!
	try {
	    impPlanDAO0.countByStatusListAndOwner(linkedList0, "Adding filter of type [", filter);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //
	}
    }

    // @Test(timeout = 4000)
    public void test30() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	LinkedList<Object> linkedList0 = new LinkedList<Object>();
	int int0 = 3;
	Integer integer0 = new Integer(3);
	LinkedHashMap<String, String> linkedHashMap0 = null;
	impPlanDAO0.getPostSegmentRelatedPlansProdLoadFallback("");
	// Undeclared exception!
	try {
	    impPlanDAO0.getPreSegmentRelatedPlans("");
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    // @Test(timeout = 4000)
    public void test31() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	LinkedList<Long> linkedList0 = new LinkedList<Long>();
	Boolean boolean0 = Boolean.valueOf(" NO");
	Integer integer0 = new Integer(2935);
	LinkedHashMap<String, String> linkedHashMap0 = Constants.LoaderTypes.getLoaderTypesList();
	List<ImpPlan> list0 = impPlanDAO0.getPlansByMacroHeader("", "", boolean0, integer0, integer0, linkedHashMap0);
	assertFalse(list0.isEmpty());
    }

    // @Test(timeout = 4000)
    public void test36() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Integer integer0 = new Integer((-7));
	List list0 = impPlanDAO0.findById("Authorization", integer0, integer0, (LinkedHashMap<String, String>) null);
	assertNull(list0);
    }

    // @Test(timeout = 4000)
    public void test37() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
	Locale locale0 = Locale.JAPAN;
	Set<String> set0 = locale0.getUnicodeLocaleKeys();
	Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.AUTOSELECT_FILTERING;
	List<String> list0 = Locale.filterTags((List<Locale.LanguageRange>) linkedList0, (Collection<String>) set0, locale_FilteringMode0);
	// Undeclared exception!
	try {
	    impPlanDAO0.getSecuredPassedLoadDate(list0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test38() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	Boolean boolean0 = Boolean.valueOf(false);
	Integer integer0 = new Integer((-2049));
	LinkedHashMap<String, String> linkedHashMap0 = Constants.LoaderTypes.getLoaderTypesList();
	// Undeclared exception!
	try {
	    // impPlanDAO0.getPlansByMacroHeader("com.tsi.workflow.utils.Constants$STAGING",
	    // boolean0, integer0,
	    // integer0, linkedHashMap0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //
	}
    }

    @Test(timeout = 4000)
    public void test40() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Integer integer0 = new Integer(0);
	// Undeclared exception!
	try {
	    impPlanDAO0.findByProject(integer0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //
	}
    }

    // @Test(timeout = 4000)
    public void test43() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	// Undeclared exception!
	try {
	    impPlanDAO0.doPlanAudit("", "");
	    fail("Expecting exception: ClassCastException");

	} catch (ClassCastException e) {
	    //
	    // org.hibernate.Filter$MockitoMock$2125743988 cannot be cast to
	    // com.tsi.workflow.beans.dao.ImpPlan
	    //

	}
    }

    @Test(timeout = 4000)
    public void test44() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	// Undeclared exception!
	try {
	    impPlanDAO0.countByStatusOnLoadTypeList("SELECT DISTINCT plan FROM ImpPlan plan, Build build WHERE plan.id = build.planId  AND plan.active = 'Y' AND plan.macroHeader = false AND plan.planStatus in (:planStatus) AND build.buildType = :buildType AND build.loadSetType = :loadType AND build.active ='Y' AND build.jobStatus = 'S'",
		    "SELECT plan.id FROM imp_plan plan, system_load load WHERE plan.id = load.plan_id AND load.load_date_time > :loaddatetime AND load.system_id = :systemid AND plan.active = 'Y' AND load.active = 'Y' AND plan.id IN (:plans)");
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //
	}
    }

    @Test(timeout = 4000)
    public void test45() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	try {
	    impPlanDAO0.countById("Plans (");
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //
	}
    }

    @Test(timeout = 4000)
    public void test46() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	Constants.BUILD_TYPE constants_BUILD_TYPE0 = Constants.BUILD_TYPE.DVL_LOAD;
	Constants.LoaderTypes constants_LoaderTypes0 = Constants.LoaderTypes.A;
	// Undeclared exception!
	try {
	    impPlanDAO0.countByQAStatusList((List<String>) null, "SM_TIMETOEXPIRE", constants_BUILD_TYPE0, constants_LoaderTypes0, (List<String>) null);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //
	}
    }

    @Test(timeout = 4000)
    public void test47() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	Constants.BUILD_TYPE constants_BUILD_TYPE0 = Constants.BUILD_TYPE.DVL_LOAD;
	Constants.LoaderTypes constants_LoaderTypes0 = Constants.LoaderTypes.E;
	// Undeclared exception!
	try {
	    impPlanDAO0.countByQAStatusList((List<String>) null, (String) null, constants_BUILD_TYPE0, constants_LoaderTypes0, (List<String>) null);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test48() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Constants.BUILD_TYPE constants_BUILD_TYPE0 = Constants.BUILD_TYPE.DVL_LOAD;
	Constants.LoaderTypes constants_LoaderTypes0 = Constants.LoaderTypes.E;
	Integer integer0 = new Integer((-1913));
	LinkedHashMap<String, String> linkedHashMap0 = new LinkedHashMap<String, String>();
	// Undeclared exception!
	try {
	    impPlanDAO0.findQAPlanList((List<String>) null, "", constants_BUILD_TYPE0, constants_LoaderTypes0, (List<String>) null, integer0, integer0, linkedHashMap0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test49() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Constants.BUILD_TYPE constants_BUILD_TYPE0 = Constants.BUILD_TYPE.DVL_LOAD;
	Constants.LoaderTypes constants_LoaderTypes0 = Constants.LoaderTypes.A;
	Integer integer0 = new Integer((-3));
	// Undeclared exception!
	try {
	    impPlanDAO0.findQAPlanList((List<String>) null, (String) null, constants_BUILD_TYPE0, constants_LoaderTypes0, (List<String>) null, integer0, integer0, (LinkedHashMap<String, String>) null);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    // @Test(timeout = 4000)

    @Test(timeout = 4000)
    public void test53() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Integer integer0 = new Integer(2358);
	// Undeclared exception!
	try {
	    impPlanDAO0.findByLoad((List<String>) null, ",", integer0, integer0, (Map<String, String>) null, null);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test54() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	// Undeclared exception!
	try {
	    impPlanDAO0.getCountOfLoad((List<String>) null, "", true, "Noor2x]Z^&Me*}}TX)R");
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test55() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Integer integer0 = new Integer(11);
	LinkedHashMap<String, String> linkedHashMap0 = Constants.LoaderTypes.getLoaderTypesList();
	// Undeclared exception!
	try {
	    impPlanDAO0.findByLoad((List<String>) null, "", true, "", integer0, integer0, false);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test56() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Integer integer0 = new Integer(3);
	// Undeclared exception!
	try {
	    impPlanDAO0.findByLoad((List<String>) null, "", false, "O$", integer0, integer0, false);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test57() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	LinkedList<String> linkedList0 = new LinkedList<String>();
	Constants.BUILD_TYPE constants_BUILD_TYPE0 = Constants.BUILD_TYPE.DVL_BUILD;
	Constants.LoaderTypes constants_LoaderTypes0 = Constants.LoaderTypes.A;
	// Undeclared exception!
	try {
	    impPlanDAO0.countByStatusListUser(linkedList0, (String) null, false, (String) null, constants_BUILD_TYPE0, constants_LoaderTypes0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test58() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
	Charset charset0 = Charset.defaultCharset();
	Set<String> set0 = charset0.aliases();
	Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.EXTENDED_FILTERING;
	List<String> list0 = Locale.filterTags((List<Locale.LanguageRange>) linkedList0, (Collection<String>) set0, locale_FilteringMode0);
	Constants.BUILD_TYPE constants_BUILD_TYPE0 = Constants.BUILD_TYPE.DVL_BUILD;
	Constants.LoaderTypes constants_LoaderTypes0 = Constants.LoaderTypes.E;
	// Undeclared exception!
	try {
	    impPlanDAO0.countByStatusListUser(list0, "", false, "", constants_BUILD_TYPE0, constants_LoaderTypes0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test59() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Constants.BUILD_TYPE constants_BUILD_TYPE0 = Constants.BUILD_TYPE.STG_CWS;
	Constants.LoaderTypes constants_LoaderTypes0 = Constants.LoaderTypes.E;
	Integer integer0 = new Integer(20);
	LinkedHashMap<String, String> linkedHashMap0 = Constants.BUILD_TYPE.getStagingBuildType();
	// Undeclared exception!
	try {
	    impPlanDAO0.findByStatusList((List<String>) null, false, false, "", "", constants_BUILD_TYPE0, constants_LoaderTypes0, integer0, integer0, linkedHashMap0, true);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test60() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Constants.BUILD_TYPE constants_BUILD_TYPE0 = Constants.BUILD_TYPE.STG_LOAD;
	Constants.LoaderTypes constants_LoaderTypes0 = Constants.LoaderTypes.E;
	Integer integer0 = new Integer(1);
	// Undeclared exception!
	try {
	    impPlanDAO0.findByStatusList((List<String>) null, true, true, "", "", constants_BUILD_TYPE0, constants_LoaderTypes0, integer0, integer0, (LinkedHashMap<String, String>) null, true);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test61() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	LinkedList<String> linkedList0 = new LinkedList<String>();
	Integer integer0 = new Integer(2);
	Constants.BUILD_TYPE constants_BUILD_TYPE0 = Constants.BUILD_TYPE.DVL_LOAD;
	Constants.LoaderTypes constants_LoaderTypes0 = Constants.LoaderTypes.E;
	LinkedHashMap<String, String> linkedHashMap0 = new LinkedHashMap<String, String>();
	// Undeclared exception!
	try {
	    impPlanDAO0.findByStatusList(linkedList0, true, true, "6!@;*FRz+Dr}`6?", "6!@;*FRz+Dr}`6?", constants_BUILD_TYPE0, constants_LoaderTypes0, integer0, integer0, linkedHashMap0, true);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test62() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Constants.BUILD_TYPE constants_BUILD_TYPE0 = Constants.BUILD_TYPE.STG_BUILD;
	Constants.LoaderTypes constants_LoaderTypes0 = Constants.LoaderTypes.A;
	Integer integer0 = new Integer((-1));
	LinkedHashMap<String, String> linkedHashMap0 = new LinkedHashMap<String, String>();
	// Undeclared exception!
	try {
	    impPlanDAO0.findByStatusList((List<String>) null, true, false, "%", "HOMEDIRECTORY", constants_BUILD_TYPE0, constants_LoaderTypes0, (Integer) null, integer0, linkedHashMap0, true);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test63() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Boolean boolean0 = Boolean.TRUE;
	// Undeclared exception!
	try {
	    impPlanDAO0.getPostSegmentRelatedPlans("TTFl w!D)Hf\"bh='&", boolean0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test64() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Boolean boolean0 = new Boolean(false);
	// Undeclared exception!
	try {
	    impPlanDAO0.getPostSegmentRelatedPlans("", boolean0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test65() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	Integer[] integerArray0 = new Integer[8];
	// Undeclared exception!
	try {
	    impPlanDAO0.findByProject(integerArray0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    // @Test(timeout = 4000)
    public void test66() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	List<Object[]> list0 = impPlanDAO0.getPreSegmentRelatedPlans("");
	assertNull(list0);
    }

    @Test(timeout = 4000)
    public void test67() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	// Undeclared exception!
	try {
	    impPlanDAO0.getBtwnSegmentRelatedPlansForLaterDate("", 3, (Date) null, (List<String>) null);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test68() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	// Undeclared exception!
	try {
	    impPlanDAO0.countById((String) null);
	    fail("Expecting exception: IllegalArgumentException");

	} catch (IllegalArgumentException e) {
	    //
	    // Comparison value passed to ilike cannot be null
	    //
	}
    }

    @Test(timeout = 4000)
    public void test69() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Integer integer0 = new Integer(1694);
	LinkedHashMap<String, String> linkedHashMap0 = new LinkedHashMap<String, String>();
	// Undeclared exception!
	try {
	    impPlanDAO0.findById((String) null, integer0, integer0, linkedHashMap0);
	    fail("Expecting exception: IllegalArgumentException");

	} catch (IllegalArgumentException e) {
	    //
	    // Comparison value passed to ilike cannot be null
	    //

	}
    }

    // @Test(timeout = 4000)
    public void test70() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	List<ImpPlan> list0 = impPlanDAO0.findByProject((Project) null);
	assertNull(list0);
    }

    @Test(timeout = 4000)
    public void test71() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	// Undeclared exception!
	try {
	    impPlanDAO0.getSameSegmentDevelopersByImpId("v", (List<String>) null);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    // @Test(timeout = 4000)
    public void test72() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	Long long0 = impPlanDAO0.countByStatusOnLoadTypeList("%", "");
	assertNull(long0);
    }

    @Test(timeout = 4000)
    public void test73() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Integer integer0 = new Integer(3);
	LinkedList<String> linkedList0 = new LinkedList<String>();
	System system0 = new System(integer0);
	// Undeclared exception!
	try {
	    impPlanDAO0.getInvalidRelatedPlans(linkedList0, system0, (Date) null);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test74() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	// Undeclared exception!
	try {
	    impPlanDAO0.getAllDependentDevelopersBySegment("tz<", (List<String>) null, "", "@=)yJCY*x");
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test75() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	// Undeclared exception!
	try {
	    impPlanDAO0.getAllRelatedPlanDetail("i", (List<String>) null);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test76() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	// Undeclared exception!
	try {
	    impPlanDAO0.getSameSegmentDevelopers("n[.O.c+,I&bM*TXoTh", (List<String>) null);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    // @Test(timeout = 4000)
    public void test77() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();
	Boolean boolean0 = Boolean.valueOf(" NO");
	Integer integer0 = new Integer(2935);
	LinkedHashMap<String, String> linkedHashMap0 = Constants.LoaderTypes.getLoaderTypesList();
	List<ImpPlan> list0 = impPlanDAO0.getPlansByMacroHeader("", "", boolean0, integer0, integer0, linkedHashMap0);
	assertNull(list0);
    }

    @Test(timeout = 4000)
    public void test81() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	AdvancedSearchForm advancedSearchForm0 = new AdvancedSearchForm();
	List<String> list0 = advancedSearchForm0.getRole();
	Constants.BUILD_TYPE constants_BUILD_TYPE0 = Constants.BUILD_TYPE.STG_LOAD;
	Constants.LoaderTypes constants_LoaderTypes0 = Constants.LoaderTypes.E;
	// Undeclared exception!
	try {
	    impPlanDAO0.countByStatusList(list0, true, " Ek=P}6s", constants_BUILD_TYPE0, constants_LoaderTypes0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    public void testCountByStatusList() {
	ImpPlanDAO instance = new ImpPlanDAO();
    }

    @Test(timeout = 4000)
    public void test82() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	User user0 = new User();
	Set<String> set0 = user0.getRole();
	LinkedList<String> linkedList0 = new LinkedList<String>(set0);
	// Undeclared exception!
	try {
	    impPlanDAO0.countByPlanStatus(set0, linkedList0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test85() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	// Undeclared exception!
	try {
	    impPlanDAO0.getPlansCountByMacroHeader("", "", (Boolean) null);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    // @Test(timeout = 4000)
    public void test86() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Integer integer0 = new Integer((-2346));
	List<ImpPlan> list0 = impPlanDAO0.findByProject(integer0);
	assertNull(list0);
    }

    @Test(timeout = 4000)
    public void test87() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	LinkedList<String> linkedList0 = new LinkedList<String>();
	Integer integer0 = new Integer((-2033));
	LinkedHashMap<String, String> linkedHashMap0 = Constants.BUILD_TYPE.getStagingBuildType();
	// Undeclared exception!
	try {
	    impPlanDAO0.findBySO(linkedList0, linkedList0, (Date) null, integer0, integer0, linkedHashMap0);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test88() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	Integer integer0 = new Integer((-1495));
	// Undeclared exception!
	try {
	    impPlanDAO0.findByStatusOnLoadTypeList("", "", integer0, (Integer) null, (LinkedHashMap<String, String>) null);
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test(timeout = 4000)
    public void test89() throws Throwable {
	ImpPlanDAO impPlanDAO0 = new ImpPlanDAO();

	// Undeclared exception!
	try {
	    impPlanDAO0.getDevelopersBySegmentForDelete("SELECT COUNT(DISTINCT (lPlan.id,lSystem.name)) ", (List<String>) null, "SELECT COUNT(DISTINCT (lPlan.id,lSystem.name)) ", Arrays.asList("SELECT COUNT(DISTINCT (lPlan.id,lSystem.name)) "));
	    fail("Expecting exception: NullPointerException");

	} catch (NullPointerException e) {
	    //
	    // no message in exception (getMessage() returned null)
	    //

	}
    }

    @Test
    public void testDeveloperManagerService() throws Exception {
	TestCaseExecutor.doTestDAO(instance, ImpPlanDAO.class);
    }

    @Test
    public void testGetPlansByLoadDateTime() {
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);

	String lQuery = "SELECT plan FROM SystemLoad sysLoad, ImpPlan plan" + " Where sysLoad.active = 'Y'" + " AND sysLoad.loadDateTime is not null" + " AND sysLoad.planId.id = plan.id" + " AND plan.planStatus = :PlanStatus" + " AND plan.devManager = :DevManagerId" + " GROUP BY plan" + " ORDER BY MIN(sysLoad.loadDateTime),1";
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createQuery(lQuery)).thenReturn(mockedQry);

	when(mockedQry.setParameter("PlanStatus", DataWareHouse.getPlan().getPlanStatus())).thenReturn(mockedQry);
	when(mockedQry.setParameter("DevManagerId", DataWareHouse.getPlan().getPlanStatus())).thenReturn(mockedQry);
	when(mockedQry.setFirstResult(5)).thenReturn(mockedQry);
	when(mockedQry.setMaxResults(5)).thenReturn(mockedQry);
	instance.getPlansByLoadDateTime(DataWareHouse.getPlan().getPlanStatus(), DataWareHouse.getPlan().getPlanStatus(), 1, 5, null);
    }

    @Test
    public void testGetPlansByLoadDateTime2() {
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);

	String lQuery = "SELECT plan FROM SystemLoad sysLoad, ImpPlan plan" + " Where sysLoad.active = 'Y'" + " AND sysLoad.loadDateTime is not null" + " AND sysLoad.planId.id = plan.id" + " AND plan.devManager = :DevManagerId" + " GROUP BY plan" + " ORDER BY MIN(sysLoad.loadDateTime),1";
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameter("DevManagerId", DataWareHouse.getPlan().getPlanStatus())).thenReturn(mockedQry);
	when(mockedQry.setFirstResult(5)).thenReturn(mockedQry);
	when(mockedQry.setMaxResults(5)).thenReturn(mockedQry);
	instance.getPlansByLoadDateTime(DataWareHouse.getPlan().getPlanStatus(), 1, 5, null, null, null);
    }

    @Test
    public void testFindByProject() throws Exception {
	ReflectionTestUtils.setField(instance, "sessionFactory", mock(SessionFactory.class));
	Session session = mock(Session.class);
	Criteria mockedCriteria = mock(Criteria.class);
	when(instance.getSessionFactory().getCurrentSession()).thenReturn(session);
	when(instance.getDAOClass()).thenReturn(ImpPlanDAO.class);
	when(session.createCriteria(ImpPlanDAO.class)).thenReturn(mockedCriteria);
	instance.findByProject(Arrays.asList(DataWareHouse.getPlan().getProjectId()));
    }

    @Test
    public void testGetPlansByMacroHeader() throws Exception {
	ReflectionTestUtils.setField(instance, "sessionFactory", mock(SessionFactory.class));
	Session session = mock(Session.class);
	Criteria mockedCriteria = mock(Criteria.class);
	when(instance.getSessionFactory().getCurrentSession()).thenReturn(session);
	when(instance.getDAOClass()).thenReturn(ImpPlanDAO.class);
	when(session.createCriteria(ImpPlanDAO.class)).thenReturn(mockedCriteria);
	instance.getPlansByMacroHeader("", DataWareHouse.getPlan().getId(), true, 0, 0, null);
	instance.findDependentPlans("");
	// instance.findByStatusList(new ArrayList(), Constants.BUILD_TYPE.DVL_LOAD,
	// Constants.LoaderTypes.E, 0, 0, new
	// LinkedHashMap<>());
	instance.findByPlanStatus(DataWareHouse.getPlan().getId(), new ArrayList());
    }

    @Test
    public void testfindByPlanStatus() throws Exception {
	ReflectionTestUtils.setField(instance, "sessionFactory", mock(SessionFactory.class));
	Session session = mock(Session.class);
	Criteria mockedCriteria = mock(Criteria.class);
	when(instance.getSessionFactory().getCurrentSession()).thenReturn(session);
	when(instance.getDAOClass()).thenReturn(ImpPlanDAO.class);
	when(session.createCriteria(ImpPlanDAO.class)).thenReturn(mockedCriteria);
	instance.findByPlanStatus(Arrays.asList(DataWareHouse.getPlan().getId()), new ArrayList());
    }

    @Test
    public void testfindById() throws Exception {
	ReflectionTestUtils.setField(instance, "sessionFactory", mock(SessionFactory.class));
	Session session = mock(Session.class);
	Criteria mockedCriteria = mock(Criteria.class);
	when(instance.getSessionFactory().getCurrentSession()).thenReturn(session);
	when(instance.getDAOClass()).thenReturn(ImpPlanDAO.class);
	when(session.createCriteria(ImpPlanDAO.class)).thenReturn(mockedCriteria);
	instance.findById("", 0, 0, new LinkedHashMap());
    }

    @Test
    public void testCountByPlanStatus() throws Exception {
	ReflectionTestUtils.setField(instance, "sessionFactory", mock(SessionFactory.class));
	Session session = mock(Session.class);
	Criteria mockedCriteria = mock(Criteria.class);
	when(instance.getSessionFactory().getCurrentSession()).thenReturn(session);
	when(instance.getDAOClass()).thenReturn(ImpPlanDAO.class);
	when(session.createCriteria(ImpPlanDAO.class)).thenReturn(mockedCriteria);
	instance.countByPlanStatus(new ArrayList(), new ArrayList());
    }

    @Test
    public void testFindByStatusListAndOwner() throws Exception {
	ReflectionTestUtils.setField(instance, "sessionFactory", mock(SessionFactory.class));
	Session session = mock(Session.class);
	Criteria mockedCriteria = mock(Criteria.class);
	String filter = "";
	when(instance.getSessionFactory().getCurrentSession()).thenReturn(session);
	when(instance.getDAOClass()).thenReturn(ImpPlanDAO.class);
	when(session.createCriteria(ImpPlanDAO.class)).thenReturn(mockedCriteria);
	instance.findByStatusListAndOwner(new ArrayList(), "", 0, 0, new LinkedHashMap(), filter);
    }

    @Test
    public void testCountByStatusListAndOwner() throws Exception {
	ReflectionTestUtils.setField(instance, "sessionFactory", mock(SessionFactory.class));
	Session session = mock(Session.class);
	Criteria mockedCriteria = mock(Criteria.class);
	String filter = "";
	when(instance.getSessionFactory().getCurrentSession()).thenReturn(session);
	when(instance.getDAOClass()).thenReturn(ImpPlanDAO.class);
	when(session.createCriteria(ImpPlanDAO.class)).thenReturn(mockedCriteria);
	instance.countByStatusListAndOwner(new ArrayList(), "", filter);
    }

    @Test
    public void testFindByProject1() throws Exception {
	ReflectionTestUtils.setField(instance, "sessionFactory", mock(SessionFactory.class));
	Session session = mock(Session.class);
	Criteria mockedCriteria = mock(Criteria.class);
	when(instance.getSessionFactory().getCurrentSession()).thenReturn(session);
	when(instance.getDAOClass()).thenReturn(ImpPlanDAO.class);
	when(session.createCriteria(ImpPlanDAO.class)).thenReturn(mockedCriteria);
	instance.findByProject((Integer[]) Arrays.asList(DataWareHouse.getPlan().getProjectId().getId()).toArray());
    }

    @Test
    public void testFind() throws Exception {
	ReflectionTestUtils.setField(instance, "sessionFactory", mock(SessionFactory.class));
	Session session = mock(Session.class);
	Criteria mockedCriteria = mock(Criteria.class);
	when(instance.getSessionFactory().getCurrentSession()).thenReturn(session);
	when(instance.getDAOClass()).thenReturn(ImpPlanDAO.class);
	when(session.createCriteria(ImpPlanDAO.class)).thenReturn(mockedCriteria);
	instance.find(Arrays.asList(DataWareHouse.getPlan().getProjectId().getId().toString()));
    }

    @Test
    public void testRemovePlanDelegate() {
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	String lQuery = "UPDATE imp_plan SET delegate_id = null, delegate_name = null WHERE dev_manager LIKE :devmanager AND plan_status IN (:status)";
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameter("devmanager", DataWareHouse.getUser().getId())).thenReturn(mockedQry);
	when(mockedQry.setParameterList("status", Constants.PlanStatus.getNonProdStatusMap().keySet())).thenReturn(mockedQry);
	instance.removePlanDelegate(DataWareHouse.getUser().getId());
    }

    @Test
    public void testSecuredPassedLoadDate() {
	String lQuery = "SELECT a.id, count(a.id) FROM imp_plan a, system_load b, build c" + " WHERE a.plan_status IN (:statuses)" + " AND b.load_date_time <= (now() - INTERVAL '2 days')" + " AND b.active = 'Y'" + " AND b.prod_load_status is null" + " AND a.active = 'Y'" + " AND c.build_type = '" + Constants.BUILD_TYPE.STG_LOAD.name() + "'" + " AND c.load_set_type = '" + Constants.LoaderTypes.E + "'" + " AND c.active ='Y'" + " AND c.job_status = 'S'" + " AND c.plan_id = a.id"
		+ " AND b.plan_id = a.id" + " GROUP BY a.id";
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	Object[] lObject = new Object[2];
	lObject[0] = DataWareHouse.getPlan().getId();
	lObject[1] = 1;
	List lList = new ArrayList();
	lList.add(lObject);
	// when(session.load(ImpPlan.class,
	// DataWareHouse.getPlan().getId())).thenReturn(lList);
	when(mockedQry.setParameterList("statuses", new ArrayList())).thenReturn(mockedQry);
	when(mockedQry.list()).thenReturn(lList);
	instance.getSecuredPassedLoadDate(new ArrayList());
	when(mockedQry.list()).thenReturn(new ArrayList());
	instance.getSecuredPassedLoadDate(new ArrayList());

    }

    @Test
    public void testGetSameSegmentDevelopers() {
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	String lQuery = "SELECT DISTINCT othSeg.imp_id, othSeg.plan_id, othPlan.lead_id, imp.dev_id , concat(othSeg.program_name,'[',othSeg.target_system,']' )" + " FROM checkout_segments othSeg ,checkout_segments seg, imp_plan othPlan, implementation imp" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'" + " AND seg.target_system = othSeg.target_system" + " AND seg.id <> othSeg.id" + " AND seg.plan_id <> othSeg.plan_id"
		+ " AND seg.plan_id = :planId" + " AND othPlan.plan_status IN (:statuses)" + " AND othPlan.id = othSeg.plan_id" + " AND imp.id = othSeg.imp_id";

	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameterList("statuses", new ArrayList())).thenReturn(mockedQry);
	when(mockedQry.setParameter("planId", "")).thenReturn(mockedQry);
	instance.getSameSegmentDevelopers("", new ArrayList());

    }

    @Test
    public void testSetPlanDelegate() {
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);

	String lQuery = "UPDATE imp_plan SET delegate_id = :approver, delegate_name = :approverName WHERE dev_manager IN ( :devmanager ) AND plan_status IN (:status)";

	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	User pApprover = DataWareHouse.getUser();
	when(mockedQry.setParameter("approver", pApprover.getId())).thenReturn(mockedQry);
	when(mockedQry.setParameter("approverName", pApprover.getDisplayName())).thenReturn(mockedQry);
	Set<String> dev = new HashSet();
	when(mockedQry.setParameterList("devmanager", dev)).thenReturn(mockedQry);
	when(mockedQry.setParameterList("status", Constants.PlanStatus.getNonProdStatusMap().keySet())).thenReturn(mockedQry);
	instance.setPlanDelegate(pApprover, dev);
    }

    @Test
    public void testFindBySO() {
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	String lQuery = "SELECT ip FROM ImpPlan ip, CheckoutSegments seg" + " WHERE seg.programName IN (:segments) AND " + " seg.planId.planStatus IN (:statuses) AND " + " seg.systemLoad.loadDateTime >= :loadDate";

	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createQuery(lQuery)).thenReturn(mockedQry);
	List<String> a = new ArrayList();
	a.add("1");
	a.add("2");
	Date load = new Date();
	when(mockedQry.setParameterList("segments", a)).thenReturn(mockedQry);
	when(mockedQry.setParameterList("statuses", a)).thenReturn(mockedQry);
	when(mockedQry.setParameter("loadDate", load)).thenReturn(mockedQry);
	instance.findBySO(a, a, load, 0, 0, new LinkedHashMap());
    }

    @Test
    public void testGetInvalidRelatedPlans() {
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);

	String lQuery = "SELECT plan.id FROM imp_plan plan, system_load load" + " WHERE plan.id = load.plan_id" + " AND load.load_date_time > :loaddatetime" + " AND load.system_id = :systemid" + " AND plan.active = 'Y'" + " AND load.active = 'Y'" + " AND plan.id IN (:plans)";

	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	User pApprover = DataWareHouse.getUser();
	Date pLoadDateTime = new Date();
	com.tsi.workflow.beans.dao.System pSystem = DataWareHouse.getSystemList().get(0);
	when(mockedQry.setParameter("loaddatetime", pLoadDateTime)).thenReturn(mockedQry);
	when(mockedQry.setParameter("systemid", pSystem.getId())).thenReturn(mockedQry);
	when(mockedQry.setParameterList("plans", Arrays.asList(DataWareHouse.getPlan().getId()))).thenReturn(mockedQry);
	instance.getInvalidRelatedPlans(Arrays.asList(DataWareHouse.getPlan().getId()), pSystem, pLoadDateTime);
    }

    @Test
    public void testGetAllRelatedPlanDetail() {
	String lQuery = "SELECT concat(OthPlan.id,'/',othsys.name), OthPlan.plan_status" + " FROM imp_plan OthPlan, system_load othLoad, system_load loadl, system othsys" + " WHERE loadl.plan_id LIKE :planid" + " AND othLoad.plan_id = OthPlan.id" + " AND othsys.id = othLoad.system_id" + " AND loadl.system_id = othLoad.system_id" + " AND OthPlan.id IN (:plans)";
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(session.load(ImpPlan.class, DataWareHouse.getPlan().getId())).thenReturn(DataWareHouse.getPlan());
	when(mockedQry.setParameter("planid", DataWareHouse.getPlan().getId())).thenReturn(mockedQry);
	when(mockedQry.setParameterList("plans", Arrays.asList(DataWareHouse.getPlan().getId()))).thenReturn(mockedQry);
	instance.getAllRelatedPlanDetail(DataWareHouse.getPlan().getId(), Arrays.asList(DataWareHouse.getPlan().getId()));
	lQuery = "SELECT concat(OthPlan.id,'/',othsys.name), OthPlan.plan_status" + " FROM imp_plan OthPlan, system_load othLoad, system_load loadl, system othsys" + " WHERE loadl.plan_id LIKE :planid" + " AND (othLoad.load_date_time < loadl.load_date_time)" + " AND othLoad.plan_id = OthPlan.id" + " AND othsys.id = othLoad.system_id" + " AND loadl.system_id = othLoad.system_id" + " AND OthPlan.id IN (:plans)";
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameter("planid", DataWareHouse.getPlan().getId())).thenReturn(mockedQry);
	when(mockedQry.setParameterList("plans", Arrays.asList(DataWareHouse.getPlan().getId()))).thenReturn(mockedQry);
	lQuery = "SELECT concat(othSeg.plan_id,'/',othSeg.target_system) , othPlan.plan_status" + " FROM checkout_segments othSeg ,checkout_segments seg, system_load othLoad, system_load loadl, imp_plan othPlan, system sys" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'" + " AND othLoad.active = 'Y'" + " AND loadl.active = 'Y'" + " AND seg.target_system = othSeg.target_system" + " AND sys.name = seg.target_system" + " AND seg.id <> othSeg.id"
		+ " AND seg.plan_id <> othSeg.plan_id" + " AND loadl.plan_id <> othLoad.plan_id" + " AND loadl.system_id = othLoad.system_id" + " AND othLoad.plan_id = othSeg.plan_id" + " AND (othLoad.load_date_time < loadl.load_date_time)" + " AND othPlan.id = othLoad.plan_id" + " AND sys.id = othLoad.system_id" + " AND loadl.plan_id = seg.plan_id" + " AND seg.plan_id LIKE ?";
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameter(0, DataWareHouse.getPlan().getId())).thenReturn(mockedQry);
	lQuery = "SELECT concat(othSeg.plan_id,'/',othSeg.target_system) , othPlan.plan_status, othPlan.id " + " FROM checkout_segments othSeg ,checkout_segments seg, system_load othLoad, " + " system_load loadl, imp_plan othPlan, system sys, imp_plan plan" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'" + " AND seg.target_system = othSeg.target_system" + " AND sys.name = seg.target_system" + " AND seg.id <> othSeg.id"
		+ " AND seg.plan_id <> othSeg.plan_id" + " AND loadl.plan_id <> othLoad.plan_id" + " AND loadl.system_id = othLoad.system_id" + " AND othLoad.plan_id = othSeg.plan_id" + " AND loadl.active = 'Y'" + " AND othLoad.active = 'Y'" + " AND othLoad.load_date_time is not null" + " AND loadl.load_date_time is not null" + " AND othLoad.load_date_time > loadl.load_date_time " + " AND othPlan.id = othLoad.plan_id" + " AND sys.id = othLoad.system_id" + " AND loadl.plan_id = seg.plan_id"
		+ " AND seg.plan_id LIKE :planId";
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameter("planId", DataWareHouse.getPlan().getId())).thenReturn(mockedQry);
	try {
	    instance.doPlanAudit(DataWareHouse.getPlan().getId(), "");
	} catch (Exception e) {
	    assertTrue(true);
	}
    }

    @Test
    public void testGetPreSegment() {
	String lQuery = "SELECT concat(othSeg.plan_id,'/',othSeg.target_system) , othPlan.plan_status" + " FROM checkout_segments othSeg ,checkout_segments seg, system_load othLoad, system_load loadl, imp_plan othPlan, system sys" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'" + " AND othLoad.active = 'Y'" + " AND loadl.active = 'Y'" + " AND seg.target_system = othSeg.target_system" + " AND sys.name = seg.target_system"
		+ " AND seg.id <> othSeg.id" + " AND seg.plan_id <> othSeg.plan_id" + " AND loadl.plan_id <> othLoad.plan_id" + " AND loadl.system_id = othLoad.system_id" + " AND othLoad.plan_id = othSeg.plan_id" + " AND (othLoad.load_date_time < loadl.load_date_time)" + " AND othPlan.id = othLoad.plan_id" + " AND sys.id = othLoad.system_id" + " AND loadl.plan_id = seg.plan_id" + " AND seg.plan_id LIKE ?";
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameter(0, DataWareHouse.getPlan().getId())).thenReturn(mockedQry);
	instance.getPreSegmentRelatedPlans(DataWareHouse.getPlan().getId());
    }

    @Test
    public void testGetPostSegment() {
	String lQuery = "SELECT concat(othSeg.plan_id,'/',othSeg.target_system) , othPlan.plan_status, othPlan.id " + " FROM checkout_segments othSeg ,checkout_segments seg, system_load othLoad, " + " system_load loadl, imp_plan othPlan, system sys, imp_plan plan" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'" + " AND seg.target_system = othSeg.target_system" + " AND sys.name = seg.target_system" + " AND seg.id <> othSeg.id"
		+ " AND seg.plan_id <> othSeg.plan_id" + " AND loadl.plan_id <> othLoad.plan_id" + " AND loadl.system_id = othLoad.system_id" + " AND othLoad.plan_id = othSeg.plan_id" + " AND loadl.active = 'Y'" + " AND othLoad.active = 'Y'" + " AND othLoad.load_date_time is not null" + " AND loadl.load_date_time is not null" + " AND othLoad.load_date_time > loadl.load_date_time " + " AND othPlan.id = othLoad.plan_id" + " AND sys.id = othLoad.system_id" + " AND loadl.plan_id = seg.plan_id"
		+ " AND plan.id = seg.plan_id" + " AND seg.plan_id LIKE :planId";
	lQuery = lQuery.concat(" AND othPlan.approve_date_time is not null " + "AND othPlan.approve_date_time < plan.approve_date_time ");

	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameter("planId", DataWareHouse.getPlan().getId())).thenReturn(mockedQry);
	Object[] lObject = new Object[3];
	List lList = new ArrayList();
	lList.add(lObject);
	when(session.load(ImpPlan.class, DataWareHouse.getPlan().getId())).thenReturn(lList);

	try {
	    instance.getPostSegmentRelatedPlans(DataWareHouse.getPlan().getId(), true);
	} catch (Exception e) {
	    assertTrue(true);
	}
    }

    @Test
    public void testGetStagingDepedendentPlans() {
	String lQuery = "SELECT DISTINCT concat(othSeg.plan_id,'_',to_char(othLoad.load_date_time,'YYMMDDHHMISS'))" + " FROM checkout_segments othSeg ,checkout_segments seg, system_load othLoad, system_load loadl, imp_plan othPlan, system sys" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'" + " AND seg.target_system = othSeg.target_system" + " AND sys.name = seg.target_system" + " AND seg.id <> othSeg.id" + " AND seg.plan_id <> othSeg.plan_id"
		+ " AND loadl.plan_id <> othLoad.plan_id" + " AND othPlan.approve_date_time is not null" + " AND loadl.system_id = othLoad.system_id" + " AND othLoad.plan_id = othSeg.plan_id" + " AND (" + "         OR(othLoad.load_date_time BETWEEN loadl.load_date_time AND  ?)" + "         OR(othLoad.load_date_time BETWEEN ? AND loadl.load_date_time)" + "     )" + " AND othPlan.id = othLoad.plan_id" + " AND sys.id = othLoad.system_id" + " AND loadl.plan_id = seg.plan_id"
		+ " AND seg.plan_id LIKE ?" + " AND sys.id = ?";

	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	Date load = new Date();
	when(mockedQry.setParameter(0, load)).thenReturn(mockedQry);
	when(mockedQry.setParameter(1, load)).thenReturn(mockedQry);
	when(mockedQry.setParameter(2, DataWareHouse.getPlan().getId())).thenReturn(mockedQry);
	when(mockedQry.setParameter(3, 1)).thenReturn(mockedQry);
	instance.getStagingDepedendentPlans(DataWareHouse.getPlan().getId(), 1, load);
    }

    @Test
    public void testDoPlanAuditForUpdate() {
	String lQuery = "SELECT concat(othSeg.plan_id,'/',othSeg.target_system) , othPlan.plan_status" + " FROM checkout_segments othSeg ,checkout_segments seg, system_load othLoad, system_load loadl, imp_plan othPlan, system sys" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'" + " AND seg.target_system = othSeg.target_system" + " AND sys.name = seg.target_system" + " AND seg.id <> othSeg.id" + " AND seg.plan_id <> othSeg.plan_id"
		+ " AND loadl.plan_id <> othLoad.plan_id" + " AND loadl.system_id = othLoad.system_id" + " AND othLoad.plan_id = othSeg.plan_id" + " AND (" + "         (othLoad.load_date_time BETWEEN loadl.load_date_time AND  ?)" + "         OR(othLoad.load_date_time BETWEEN ? AND loadl.load_date_time)" + "     )" + " AND othPlan.id = othLoad.plan_id" + " AND sys.id = othLoad.system_id" + " AND loadl.plan_id = seg.plan_id" + " AND seg.plan_id LIKE ?" + " AND sys.id = ?";
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	Date load = null;
	when(mockedQry.setParameter(0, load)).thenReturn(mockedQry);
	when(mockedQry.setParameter(1, load)).thenReturn(mockedQry);
	when(mockedQry.setParameter(2, DataWareHouse.getPlan().getId())).thenReturn(mockedQry);
	when(mockedQry.setParameter(3, 1)).thenReturn(mockedQry);
	Object[] lObject = new Object[2];
	lObject[0] = DataWareHouse.getPlan().getId() + "/APO";
	lObject[1] = Constants.PlanStatus.APPROVED.name();
	List<Object[]> lList = new ArrayList();
	lList.add(lObject);
	instance.doPlanAuditForUpdate(DataWareHouse.getPlan().getId(), 1, load);
    }

    @Test
    public void testGetDevelopersBySegment() {
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);

	String lQuery = "SELECT DISTINCT othSeg.imp_id, othSeg.plan_id, othPlan.lead_id, imp.dev_id , concat(othSeg.file_name,'[',othSeg.target_system,']' )," + " othPlan.load_type, othPlan.plan_status, imp.id , sysLoad.load_date_time" + " FROM checkout_segments othSeg ,checkout_segments seg, imp_plan othPlan, implementation imp," + " system_load othSysLoad, system_load sysLoad" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'"
		+ " AND seg.target_system = othSeg.target_system" + " AND seg.id <> othSeg.id" + " AND seg.plan_id <> othSeg.plan_id" + " AND othPlan.id = othSeg.plan_id" + " AND othPlan.plan_status IN (:statuses)" + " AND imp.id = othSeg.imp_id" + " AND seg.plan_id = :planId" + " AND seg.target_system = :targetSystem " + " AND seg.file_name = :segmentName" + " AND sysLoad.id = othSeg.system_load" + " AND othSysLoad.id = seg.system_load" + " AND sysLoad.load_date_time IS NOT NULL "
		+ " AND othSysLoad.load_date_time IS NOT NULL " + " AND sysLoad.load_date_time < othSysLoad.load_date_time" + " ORDER BY sysLoad.load_date_time DESC LIMIT 1";

	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameterList("statuses", new ArrayList())).thenReturn(mockedQry);
	when(mockedQry.setParameter("planId", "")).thenReturn(mockedQry);
	when(mockedQry.setParameter("targetSystem", "")).thenReturn(mockedQry);
	when(mockedQry.setParameter("segmentName", "")).thenReturn(mockedQry);

	instance.getDevelopersBySegment("", new ArrayList(), "", "");
    }

    @Test
    public void testGetDevelopersByTargetSystem() {
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);

	String lQuery = "SELECT DISTINCT othSeg.imp_id, othSeg.plan_id, othPlan.lead_id, imp.dev_id , concat(othSeg.program_name,'[',othSeg.target_system,']' )," + " othPlan.load_type, othPlan.plan_status, imp.id , sysLoad.load_date_time" + " FROM checkout_segments othSeg ,checkout_segments seg, imp_plan othPlan, implementation imp," + " system_load othSysLoad, system_load sysLoad" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'"
		+ " AND seg.target_system = othSeg.target_system" + " AND seg.id <> othSeg.id" + " AND seg.plan_id <> othSeg.plan_id" + " AND othPlan.id = othSeg.plan_id" + " AND imp.id = othSeg.imp_id" + " AND seg.plan_id = :planId" + " AND seg.target_system = :targetSystem " + " AND sysLoad.id = othSeg.system_load" + " AND othSysLoad.id = seg.system_load" + " AND sysLoad.load_date_time IS NOT NULL " + " AND othSysLoad.load_date_time IS NOT NULL "
		+ " AND sysLoad.load_date_time > othSysLoad.load_date_time" + " ORDER BY sysLoad.load_date_time ";
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameter("statuses", "")).thenReturn(mockedQry);
	when(mockedQry.setParameter("planId", "")).thenReturn(mockedQry);
	when(mockedQry.setParameter("targetSystem", "")).thenReturn(mockedQry);

	instance.getDevelopersByTargetSystem("", "");
    }

    @Test
    public void testGetSameSegmentDevelopersByImpId() {
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);

	String lQuery = "SELECT DISTINCT othSeg.imp_id, othSeg.plan_id, othPlan.lead_id, imp.dev_id, concat(othSeg.program_name,'[',othSeg.target_system,']' )" + " FROM checkout_segments othSeg ,checkout_segments seg, imp_plan othPlan, implementation imp" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'" + " AND seg.target_system = othSeg.target_system" + " AND seg.id <> othSeg.id" + " AND seg.plan_id <> othSeg.plan_id"
		+ " AND othPlan.id = othSeg.plan_id" + " AND seg.imp_id = :impId" + " AND othPlan.plan_status IN (:statuses)" + " AND imp.id = othSeg.imp_id";
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameterList("statuses", new ArrayList())).thenReturn(mockedQry);
	when(mockedQry.setParameter("impId", "")).thenReturn(mockedQry);

	instance.getSameSegmentDevelopersByImpId("", new ArrayList());
    }

    @Test
    public void testGetPostSegmentRelatedPlansProdLoad() {
	String lQuery = "SELECT concat(othSeg.plan_id,'/',othSeg.target_system) , othPlan.plan_status, othPlan.id " + " FROM checkout_segments othSeg ,checkout_segments seg, system_load othLoad, " + " system_load loadl, imp_plan othPlan, system sys" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'" + " AND seg.target_system = othSeg.target_system" + " AND sys.name = seg.target_system" + " AND seg.id <> othSeg.id"
		+ " AND seg.plan_id <> othSeg.plan_id" + " AND loadl.plan_id <> othLoad.plan_id" + " AND loadl.system_id = othLoad.system_id" + " AND othLoad.prod_load_status LIKE 'ACTIVATED%'" + " AND othLoad.plan_id = othSeg.plan_id" + " AND loadl.active = 'Y'" + " AND othLoad.active = 'Y'" + " AND othLoad.load_date_time is not null" + " AND loadl.load_date_time is not null" + " AND othLoad.load_date_time > loadl.load_date_time " + " AND othPlan.id = othLoad.plan_id"
		+ " AND sys.id = othLoad.system_id" + " AND loadl.plan_id = seg.plan_id" + " AND seg.plan_id LIKE ?";

	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameter(0, DataWareHouse.getPlan().getId())).thenReturn(mockedQry);
	Object[] lObject = new Object[3];
	List lList = new ArrayList();
	lList.add(lObject);
	when(session.load(ImpPlan.class, DataWareHouse.getPlan().getId())).thenReturn(lList);

	try {
	    instance.getPostSegmentRelatedPlansProdLoad(DataWareHouse.getPlan().getId());
	} catch (Exception e) {
	    assertTrue(true);
	}
    }

    @Test
    public void testGetPostSegmentRelatedPlansProdLoadFallbackLoad() {
	String lQuery = "SELECT concat(othSeg.plan_id,'/',othSeg.target_system) , othPlan.plan_status, othPlan.id " + " FROM checkout_segments othSeg ,checkout_segments seg, system_load othLoad, " + " system_load loadl, imp_plan othPlan, system sys" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'" + " AND seg.target_system = othSeg.target_system" + " AND sys.name = seg.target_system" + " AND seg.id <> othSeg.id"
		+ " AND seg.plan_id <> othSeg.plan_id" + " AND loadl.plan_id <> othLoad.plan_id" + " AND loadl.system_id = othLoad.system_id" + " AND othLoad.prod_load_status in ('ACTIVATED_ON_ALL_CPU','ACCEPTED','FALLBACK_DELETED','ACTIVATED_ON_SINGLE_CPU','ACTIVATED_ON_MULTIPLE_CPU')" + " AND othLoad.plan_id = othSeg.plan_id" + " AND loadl.active = 'Y'" + " AND othLoad.active = 'Y'" + " AND othLoad.load_date_time is not null" + " AND loadl.load_date_time is not null"
		+ " AND othLoad.load_date_time > loadl.load_date_time " + " AND othPlan.id = othLoad.plan_id" + " AND sys.id = othLoad.system_id" + " AND loadl.plan_id = seg.plan_id" + " AND seg.plan_id LIKE ?";

	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameter(0, DataWareHouse.getPlan().getId())).thenReturn(mockedQry);
	Object[] lObject = new Object[3];
	List lList = new ArrayList();
	lList.add(lObject);
	when(session.load(ImpPlan.class, DataWareHouse.getPlan().getId())).thenReturn(lList);
	try {
	    instance.getPostSegmentRelatedPlansProdLoadFallbackLoad(DataWareHouse.getPlan().getId(), Boolean.TRUE);
	} catch (Exception e) {
	    assertTrue(true);
	}
    }

    @Test
    public void testGetPostSegmentRelatedPlansProdLoadFallback() {
	String lQuery = "SELECT concat(othSeg.plan_id,'/',othSeg.target_system) , othPlan.plan_status, othPlan.id " + " FROM checkout_segments othSeg ,checkout_segments seg, system_load othLoad, " + " system_load loadl, imp_plan othPlan, system sys" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'" + " AND seg.target_system = othSeg.target_system" + " AND sys.name = seg.target_system" + " AND seg.id <> othSeg.id"
		+ " AND seg.plan_id <> othSeg.plan_id" + " AND loadl.plan_id <> othLoad.plan_id" + " AND loadl.system_id = othLoad.system_id" + " AND othLoad.prod_load_status is not null" + " AND othLoad.plan_id = othSeg.plan_id" + " AND loadl.active = 'Y'" + " AND othLoad.active = 'Y'" + " AND othLoad.load_date_time is not null" + " AND loadl.load_date_time is not null" + " AND othLoad.load_date_time > loadl.load_date_time " + " AND othPlan.id = othLoad.plan_id"
		+ " AND sys.id = othLoad.system_id" + " AND loadl.plan_id = seg.plan_id" + " AND seg.plan_id LIKE ?";

	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameter(0, DataWareHouse.getPlan().getId())).thenReturn(mockedQry);
	Object[] lObject = new Object[3];
	List lList = new ArrayList();
	lList.add(lObject);
	when(session.load(ImpPlan.class, DataWareHouse.getPlan().getId())).thenReturn(lList);
	try {
	    instance.getPostSegmentRelatedPlansProdLoadFallback(DataWareHouse.getPlan().getId());
	} catch (Exception e) {
	    assertTrue(true);
	}
    }

    @Test
    public void testGetBtwnSegmentRelatedPlansForLaterDate() {
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);

	String lQuery = "SELECT concat(othSeg.plan_id,'/',othSeg.target_system) , othPlan.plan_status, othPlan.id" + " FROM checkout_segments othSeg ,checkout_segments seg, system_load othLoad, system_load loadl, imp_plan othPlan, system sys" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'" + " AND seg.target_system = othSeg.target_system" + " AND sys.name = seg.target_system" + " AND seg.id <> othSeg.id" + " AND seg.plan_id <> othSeg.plan_id"
		+ " AND loadl.plan_id <> othLoad.plan_id" + " AND loadl.system_id = othLoad.system_id" + " AND loadl.active = 'Y'" + " AND othLoad.active = 'Y'" + " AND othLoad.plan_id = othSeg.plan_id" + " AND (" + "         othLoad.load_date_time is not null " + "         AND loadl.load_date_time is not null " + "         AND othLoad.load_date_time BETWEEN loadl.load_date_time AND :loadDate" + "     )" + " AND othPlan.id = othLoad.plan_id" + " AND sys.id = othLoad.system_id"
		+ " AND loadl.plan_id = seg.plan_id" + " AND seg.plan_id LIKE :planId" + " AND othPlan.plan_status IN (:statuses)";

	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameter("planId", DataWareHouse.getPlan().getId())).thenReturn(mockedQry);
	when(mockedQry.setParameter("loadDate", DataWareHouse.getPlan().getSystemLoadList().get(0).getLoadDateTime())).thenReturn(mockedQry);
	when(mockedQry.setParameterList("statuses", Arrays.asList(DataWareHouse.getPlan().getPlanStatus()))).thenReturn(mockedQry);

	instance.getBtwnSegmentRelatedPlansForLaterDate(DataWareHouse.getPlan().getId(), 0, DataWareHouse.getPlan().getSystemLoadList().get(0).getLoadDateTime(), Arrays.asList(DataWareHouse.getPlan().getPlanStatus()));
    }

    @Test
    public void testGtPostSegmentRelatedPlansBySystem() {

	String lQuery = "SELECT othLoad.load_date_time, othPlan.plan_status, othPlan.id " + " FROM checkout_segments othSeg ,checkout_segments seg, system_load othLoad, " + " system_load loadl, imp_plan othPlan, system sys" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'" + " AND loadl.active = 'Y'" + " AND othLoad.active = 'Y'" + " AND seg.target_system = othSeg.target_system" + " AND sys.name = seg.target_system" + " AND seg.id <> othSeg.id"
		+ " AND seg.plan_id <> othSeg.plan_id" + " AND loadl.plan_id <> othLoad.plan_id" + " AND loadl.system_id = othLoad.system_id" + " AND othLoad.plan_id = othSeg.plan_id" + " AND othLoad.load_date_time > loadl.load_date_time" + " AND othPlan.id = othLoad.plan_id" + " AND sys.id = othLoad.system_id" + " AND loadl.plan_id = seg.plan_id" + " AND seg.plan_id = :planId" + " AND seg.target_system = :targetSystem" + " AND othPlan.plan_status IN (:statuses)";

	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameter(0, DataWareHouse.getPlan().getId())).thenReturn(mockedQry);
	Object[] lObject = new Object[3];
	List lList = new ArrayList();
	lList.add(lObject);
	when(session.load(ImpPlan.class, DataWareHouse.getPlan().getId())).thenReturn(lList);
	when(mockedQry.setParameter("planId", DataWareHouse.getPlan().getId())).thenReturn(mockedQry);
	when(mockedQry.setParameter("targetSystem", "APO")).thenReturn(mockedQry);
	when(mockedQry.setParameterList("statuses", Arrays.asList(DataWareHouse.getPlan().getPlanStatus()))).thenReturn(mockedQry);
	try {
	    instance.getPostSegmentRelatedPlansBySystem(DataWareHouse.getPlan().getId(), "APO", Arrays.asList(DataWareHouse.getPlan().getPlanStatus()));
	} catch (Exception e) {
	    assertTrue(true);
	}
    }

    @Test
    public void testGetAllDependentDevelopersBySegment() {
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);

	String lQuery = "SELECT DISTINCT othSeg.imp_id, othSeg.plan_id, othPlan.lead_id, imp.dev_id , concat(othSeg.file_name,'[',othSeg.target_system,']' )," + " othPlan.load_type, othPlan.plan_status, imp.id , sysLoad.load_date_time" + " FROM checkout_segments othSeg ,checkout_segments seg, imp_plan othPlan, implementation imp," + " system_load othSysLoad, system_load sysLoad" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'"
		+ " AND seg.target_system = othSeg.target_system" + " AND seg.id <> othSeg.id" + " AND seg.plan_id <> othSeg.plan_id" + " AND othPlan.id = othSeg.plan_id" + " AND othPlan.plan_status IN (:statuses)" + " AND imp.id = othSeg.imp_id" + " AND seg.plan_id = :planId" + " AND seg.target_system = :targetSystem " + " AND seg.file_name = :segmentName" + " AND sysLoad.id = othSeg.system_load" + " AND othSysLoad.id = seg.system_load" + " AND sysLoad.load_date_time IS NOT NULL "
		+ " AND othSysLoad.load_date_time IS NOT NULL " + " AND sysLoad.load_date_time > othSysLoad.load_date_time" + " ORDER BY sysLoad.load_date_time LIMIT 1";

	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameter("planId", DataWareHouse.getPlan().getId())).thenReturn(mockedQry);
	when(mockedQry.setParameter("targetSystem", "APO")).thenReturn(mockedQry);
	when(mockedQry.setParameter("segmentName", "")).thenReturn(mockedQry);
	when(mockedQry.setParameterList("statuses", Arrays.asList(DataWareHouse.getPlan().getPlanStatus()))).thenReturn(mockedQry);
	try {
	    instance.getAllDependentDevelopersBySegment(DataWareHouse.getPlan().getId(), Arrays.asList(DataWareHouse.getPlan().getPlanStatus()), "", "APO");
	} catch (Exception e) {
	    assertTrue(true);
	}
    }

    @Test
    public void testGetDevelopersBySegmentForDelete() {
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);

	String lQuery = "SELECT DISTINCT othSeg.imp_id, othSeg.plan_id, othPlan.lead_id, imp.dev_id , concat(othSeg.file_name,'[',othSeg.target_system,']' )," + " othPlan.load_type, othPlan.plan_status, imp.id " + " FROM checkout_segments othSeg ,checkout_segments seg, imp_plan othPlan, implementation imp," + " system_load othSysLoad, system_load sysLoad" + " WHERE seg.file_name = othSeg.file_name" + " AND seg.active = 'Y'" + " AND othSeg.active = 'Y'"
		+ " AND seg.target_system = othSeg.target_system" + " AND seg.id <> othSeg.id" + " AND seg.plan_id <> othSeg.plan_id" + " AND othPlan.id = othSeg.plan_id" + " AND othPlan.plan_status IN (:statuses)" + " AND imp.id = othSeg.imp_id" + " AND seg.plan_id = :planId" + " AND seg.target_system IN (:targetSystem)" + " AND seg.program_name = :segmentName" + " AND sysLoad.id = seg.system_load" + " AND othSysLoad.id = othSeg.system_load"
		+ " AND ((sysLoad.load_date_time IS NOT NULL) AND (othSysLoad.load_date_time IS NOT NULL) " + " AND (sysLoad.load_date_time < othSysLoad.load_date_time))";

	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameterList("statuses", Arrays.asList(DataWareHouse.getPlan().getPlanStatus()))).thenReturn(mockedQry);
	when(mockedQry.setParameter("planId", DataWareHouse.getPlan().getId())).thenReturn(mockedQry);
	when(mockedQry.setParameterList("targetSystem", Arrays.asList("APO"))).thenReturn(mockedQry);
	when(mockedQry.setParameter("segmentName", "")).thenReturn(mockedQry);

	instance.getDevelopersBySegmentForDelete(DataWareHouse.getPlan().getId(), Arrays.asList(DataWareHouse.getPlan().getPlanStatus()), "", Arrays.asList("APO"));
    }

    @Test
    public void testFindByLoad() {
	try {
	    String filter = "";
	    Integer pOffset = 0;
	    Integer pLimit = 10;
	    LinkedHashMap<String, String> orderBy = new LinkedHashMap();
	    orderBy.put("id", "asc");
	    List<String> planStatus = new ArrayList();
	    planStatus.add(Constants.PlanStatus.APPROVED.name());
	    String loadSetType = "";
	    SessionFactory sessionFactory = mock(SessionFactory.class);
	    ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	    Session session = mock(Session.class);
	    SQLQuery mockedQry = mock(SQLQuery.class);
	    String lQuery = "SELECT DISTINCT plan FROM ImpPlan plan, Build build1" + " WHERE plan.active = 'Y'" + " AND plan.planStatus IN (:Statuses)" + " AND build1.active = 'Y'" + " AND build1.planId.id = plan.id" + " AND build1.buildType = :BuildType" + " AND build1.loadSetType = :LoadSetType";
	    lQuery = lQuery + " ORDER BY plan.id asc";
	    when(sessionFactory.getCurrentSession()).thenReturn(session);
	    when(session.createQuery(lQuery)).thenReturn(mockedQry);
	    when(mockedQry.setParameterList(Matchers.any(), Matchers.anyCollection())).thenReturn(mockedQry);
	    when(mockedQry.setParameter(Matchers.any(), Matchers.any())).thenReturn(mockedQry);
	    when(mockedQry.setFirstResult(pOffset * pLimit)).thenReturn(mockedQry);
	    when(mockedQry.setMaxResults(pLimit)).thenReturn(mockedQry);

	    instance.findByLoad(planStatus, loadSetType, pOffset, pLimit, orderBy, filter);
	} catch (Exception ex) {
	    assertTrue(true);
	}
    }

    @Test
    public void testFindByLoad1() {
	try {
	    String filter = "";
	    Integer pOffset = 0;
	    Integer pLimit = 10;
	    LinkedHashMap<String, String> orderBy = new LinkedHashMap();
	    List<String> planStatus = new ArrayList();
	    planStatus.add(Constants.PlanStatus.APPROVED.name());
	    String loadSetType = "";
	    SessionFactory sessionFactory = mock(SessionFactory.class);
	    ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	    Session session = mock(Session.class);
	    SQLQuery mockedQry = mock(SQLQuery.class);
	    String lQuery = "SELECT DISTINCT plan FROM ImpPlan plan, Build build1" + " WHERE plan.active = 'Y'" + " AND plan.planStatus IN (:Statuses)" + " AND build1.active = 'Y'" + " AND build1.planId.id = plan.id" + " AND build1.buildType = :BuildType" + " AND build1.loadSetType = :LoadSetType";
	    lQuery = lQuery + " ORDER BY plan.id asc";
	    when(sessionFactory.getCurrentSession()).thenReturn(session);
	    when(session.createQuery(lQuery)).thenReturn(mockedQry);
	    when(mockedQry.setParameterList(Matchers.any(), Matchers.anyCollection())).thenReturn(mockedQry);
	    when(mockedQry.setParameter(Matchers.any(), Matchers.any())).thenReturn(mockedQry);
	    when(mockedQry.setFirstResult(pOffset * pLimit)).thenReturn(mockedQry);
	    when(mockedQry.setMaxResults(pLimit)).thenReturn(mockedQry);

	    instance.findByLoad(planStatus, loadSetType, pOffset, pLimit, orderBy, filter);
	} catch (Exception ex) {
	    assertTrue(true);
	}
    }

    @Test
    public void testGetCountOfLoad() {
	try {
	    String filter = "";
	    Integer pOffset = 0;
	    Integer pLimit = 10;
	    LinkedHashMap<String, String> orderBy = new LinkedHashMap();
	    orderBy.put("id", "asc");
	    List<String> planStatus = new ArrayList();
	    planStatus.add(Constants.PlanStatus.APPROVED.name());
	    String loadSetType = "";
	    SessionFactory sessionFactory = mock(SessionFactory.class);
	    ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	    Session session = mock(Session.class);
	    SQLQuery mockedQry = mock(SQLQuery.class);
	    String lQuery = "SELECT COUNT(DISTINCT plan) FROM ImpPlan plan, Build build1" + " WHERE plan.active = 'Y'" + " AND plan.planStatus IN (:Statuses)" + " AND build1.active = 'Y'" + " AND build1.planId.id = plan.id" + " AND build1.buildType = :BuildType" + " AND build1.loadSetType = :LoadSetType";
	    when(sessionFactory.getCurrentSession()).thenReturn(session);
	    when(session.createQuery(lQuery)).thenReturn(mockedQry);
	    when(mockedQry.setParameterList("Statuses", planStatus)).thenReturn(mockedQry);
	    when(mockedQry.setParameter("BuildType", Constants.BUILD_TYPE.STG_LOAD.name())).thenReturn(mockedQry);
	    when(mockedQry.setParameter("LoadSetType", loadSetType)).thenReturn(mockedQry);

	    instance.getCountOfLoad(planStatus, loadSetType, filter);
	} catch (Exception ex) {
	    assertTrue(true);
	}
    }

    @Test
    public void testFindByStatusList() {
	String pLeadName = DataWareHouse.getUser().getId();
	Boolean leadCheck = true;
	Boolean isDelta = true;
	String pFilter = "test";
	Integer offset = 0;
	Integer limit = 10;
	Constants.BUILD_TYPE build_type = Constants.BUILD_TYPE.DVL_BUILD;
	Constants.LoaderTypes loaderTypes = Constants.LoaderTypes.A;
	LinkedHashMap<String, String> lOrderBy = new LinkedHashMap();
	lOrderBy.put("id", "ASC");
	List<String> status = new ArrayList();
	status.add("test");
	String lQueryString = "SELECT DISTINCT plan FROM ImpPlan plan, Build build" + " WHERE plan.id = build.planId " + " AND plan.active = 'Y'" + " AND plan.macroHeader = false" + " AND plan.planStatus in (:planStatus)" + " AND build.buildType = :buildType" + " AND build.loadSetType = :loadType" + " AND build.active ='Y'" + " AND build.jobStatus = 'S'";
	String lAppendQuery = "";

	if (leadCheck && pLeadName != null && !pLeadName.isEmpty()) {
	    lAppendQuery = lAppendQuery + " AND plan.leadId  = '" + pLeadName + "'";
	} else if (!leadCheck && pLeadName != null && !pLeadName.isEmpty()) {
	    lAppendQuery = lAppendQuery + " AND plan.leadId <> '" + pLeadName + "'";
	}

	// This is only for Delta TSS, So NO ELSE
	if (isDelta) {
	    lAppendQuery = lAppendQuery + " AND plan.id LIKE 'D%'";
	}

	if (pFilter != null && !pFilter.isEmpty()) {
	    lAppendQuery = lAppendQuery + " AND plan.id LIKE '%" + pFilter + "%'";
	}
	String lOrderByString = "";

	if (lOrderBy != null && !lOrderBy.isEmpty()) {
	    for (Map.Entry<String, String> entrySet : lOrderBy.entrySet()) {
		String key = entrySet.getKey();
		String value = entrySet.getValue();
		lOrderByString = " ORDER BY plan." + key + " " + value;
	    }
	}
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createQuery(lQueryString + lAppendQuery + lOrderByString)).thenReturn(mockedQry);
	when(mockedQry.setParameterList(Matchers.any(), Matchers.anyCollection())).thenReturn(mockedQry);
	when(mockedQry.setParameter(Matchers.any(), Matchers.any())).thenReturn(mockedQry);
	when(mockedQry.setFirstResult(offset * limit)).thenReturn(mockedQry);
	when(mockedQry.setMaxResults(limit)).thenReturn(mockedQry);
	// when(session.load(ImpPlan.class,
	// DataWareHouse.getPlan().getId())).thenReturn(Arrays.asList(DataWareHouse.getPlan()));

	instance.findByStatusList(status, isDelta, leadCheck, pLeadName, pFilter, build_type, loaderTypes, offset, limit, lOrderBy, true);
    }

    @Test
    public void testFindByStatusList1() {
	String pLeadName = DataWareHouse.getUser().getId();
	Boolean leadCheck = false;
	Boolean isDelta = false;
	String pFilter = null;
	Integer offset = 0;
	Integer limit = 10;
	Constants.BUILD_TYPE build_type = Constants.BUILD_TYPE.DVL_BUILD;
	Constants.LoaderTypes loaderTypes = Constants.LoaderTypes.A;
	LinkedHashMap<String, String> lOrderBy = new LinkedHashMap();
	lOrderBy.put("id", "ASC");
	List<String> status = new ArrayList();
	status.add("test");
	String lQueryString = "SELECT DISTINCT plan FROM ImpPlan plan, Build build" + " WHERE plan.id = build.planId " + " AND plan.active = 'Y'" + " AND plan.macroHeader = false" + " AND plan.planStatus in (:planStatus)" + " AND build.buildType = :buildType" + " AND build.loadSetType = :loadType" + " AND build.active ='Y'" + " AND build.jobStatus = 'S'";
	String lAppendQuery = "";

	if (leadCheck && pLeadName != null && !pLeadName.isEmpty()) {
	    lAppendQuery = lAppendQuery + " AND plan.leadId  = '" + pLeadName + "'";
	} else if (!leadCheck && pLeadName != null && !pLeadName.isEmpty()) {
	    lAppendQuery = lAppendQuery + " AND plan.leadId <> '" + pLeadName + "'";
	}

	// This is only for Delta TSS, So NO ELSE
	if (isDelta) {
	    lAppendQuery = lAppendQuery + " AND plan.id LIKE 'D%'";
	}

	if (pFilter != null && !pFilter.isEmpty()) {
	    lAppendQuery = lAppendQuery + " AND plan.id LIKE '%" + pFilter + "%'";
	}
	String lOrderByString = "";

	if (lOrderBy != null && !lOrderBy.isEmpty()) {
	    for (Map.Entry<String, String> entrySet : lOrderBy.entrySet()) {
		String key = entrySet.getKey();
		String value = entrySet.getValue();
		lOrderByString = " ORDER BY plan." + key + " " + value;
	    }
	}
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createQuery(lQueryString + lAppendQuery + lOrderByString)).thenReturn(mockedQry);
	when(mockedQry.setParameterList(Matchers.any(), Matchers.anyCollection())).thenReturn(mockedQry);
	when(mockedQry.setParameter(Matchers.any(), Matchers.any())).thenReturn(mockedQry);
	when(mockedQry.setFirstResult(offset * limit)).thenReturn(mockedQry);
	when(mockedQry.setMaxResults(limit)).thenReturn(mockedQry);
	// when(session.load(ImpPlan.class,
	// DataWareHouse.getPlan().getId())).thenReturn(Arrays.asList(DataWareHouse.getPlan()));

	instance.findByStatusList(status, isDelta, leadCheck, pLeadName, pFilter, build_type, loaderTypes, offset, limit, lOrderBy, true);
    }

    @Test
    public void testFindByStatusList2() {
	String pLeadName = "";
	Boolean leadCheck = true;
	Boolean isDelta = false;
	String pFilter = null;
	Integer offset = 0;
	Integer limit = 10;
	Constants.BUILD_TYPE build_type = Constants.BUILD_TYPE.DVL_BUILD;
	Constants.LoaderTypes loaderTypes = Constants.LoaderTypes.A;
	LinkedHashMap<String, String> lOrderBy = new LinkedHashMap();
	lOrderBy.put("id", "ASC");
	List<String> status = new ArrayList();
	status.add("test");
	String lQueryString = "SELECT DISTINCT plan FROM ImpPlan plan, Build build" + " WHERE plan.id = build.planId " + " AND plan.active = 'Y'" + " AND plan.macroHeader = false" + " AND plan.planStatus in (:planStatus)" + " AND build.buildType = :buildType" + " AND build.loadSetType = :loadType" + " AND build.active ='Y'" + " AND build.jobStatus = 'S'";
	String lAppendQuery = "";

	if (leadCheck && pLeadName != null && !pLeadName.isEmpty()) {
	    lAppendQuery = lAppendQuery + " AND plan.leadId  = '" + pLeadName + "'";
	} else if (!leadCheck && pLeadName != null && !pLeadName.isEmpty()) {
	    lAppendQuery = lAppendQuery + " AND plan.leadId <> '" + pLeadName + "'";
	}

	// This is only for Delta TSS, So NO ELSE
	if (isDelta) {
	    lAppendQuery = lAppendQuery + " AND plan.id LIKE 'D%'";
	}

	if (pFilter != null && !pFilter.isEmpty()) {
	    lAppendQuery = lAppendQuery + " AND plan.id LIKE '%" + pFilter + "%'";
	}
	String lOrderByString = "";

	if (lOrderBy != null && !lOrderBy.isEmpty()) {
	    for (Map.Entry<String, String> entrySet : lOrderBy.entrySet()) {
		String key = entrySet.getKey();
		String value = entrySet.getValue();
		lOrderByString = " ORDER BY plan." + key + " " + value;
	    }
	}
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createQuery(lQueryString + lAppendQuery + lOrderByString)).thenReturn(mockedQry);
	when(mockedQry.setParameterList(Matchers.any(), Matchers.anyCollection())).thenReturn(mockedQry);
	when(mockedQry.setParameter(Matchers.any(), Matchers.any())).thenReturn(mockedQry);
	when(mockedQry.setFirstResult(offset * limit)).thenReturn(mockedQry);
	when(mockedQry.setMaxResults(limit)).thenReturn(mockedQry);
	// when(session.load(ImpPlan.class,
	// DataWareHouse.getPlan().getId())).thenReturn(Arrays.asList(DataWareHouse.getPlan()));

	instance.findByStatusList(status, isDelta, leadCheck, pLeadName, pFilter, build_type, loaderTypes, offset, limit, lOrderBy, true);
    }

    @Test
    public void testCountByStatusListUser() {
	List<String> status = new ArrayList();
	status.add("test");
	String pUser = DataWareHouse.getUser().getId();
	Boolean isDelta = true;
	String pFilter = "test";
	Constants.BUILD_TYPE build_type = Constants.BUILD_TYPE.DVL_BUILD;
	Constants.LoaderTypes loaderTypes = Constants.LoaderTypes.A;

	String lQueryString = "SELECT count(DISTINCT plan) FROM ImpPlan plan, Build build" + " WHERE plan.id = build.planId " + " AND plan.active = 'Y'" + " AND plan.macroHeader = false" + " AND plan.planStatus in (:planStatus)" + " AND build.buildType = :buildType" + " AND build.loadSetType = :loadType" + " AND build.active ='Y'" + " AND build.jobStatus = 'S'";
	String lAppendQuery = "";

	if (pUser != null && !pUser.isEmpty()) {
	    lAppendQuery = lAppendQuery + " AND plan.leadId = '" + pUser + "'";
	}

	if (isDelta) {
	    lAppendQuery = lAppendQuery + " AND plan LIKE 'D%'";
	}
	if (pFilter != null && !pFilter.isEmpty()) {
	    lAppendQuery = lAppendQuery + " AND plan.id LIKE '%" + pFilter + "%'";
	}
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createQuery(lQueryString + lAppendQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameterList(Matchers.any(), Matchers.anyCollection())).thenReturn(mockedQry);
	when(mockedQry.setParameter(Matchers.any(), Matchers.any())).thenReturn(mockedQry);

	instance.countByStatusListUser(status, pUser, isDelta, pFilter, build_type, loaderTypes);
    }

    @Test
    public void testGetCountOfAdvancedSearch() {
	String lQuery = "";
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameterList(Matchers.any(), Matchers.anyCollection())).thenReturn(mockedQry);
	when(mockedQry.setParameter(Matchers.any(), Matchers.any())).thenReturn(mockedQry);

    }

    @Test
    public void testFindByLoad2() {
	List<String> planStatus = new ArrayList();
	planStatus.add(DataWareHouse.getPlan().getPlanStatus());
	Boolean isDelta = true;
	String loadSetType = "E";
	Map<String, String> orderBy = new HashMap();
	orderBy.put("id", "ASC");
	Integer offset = 0;
	Integer limit = 10;
	String pFilter = DataWareHouse.getPlan().getId();
	List<String> status = new ArrayList<>();
	status.add(DataWareHouse.getPlan().getPlanStatus());
	StringBuilder lQuery = new StringBuilder("select plan from ImpPlan plan, Build b, SystemLoad load" + " where " + " plan.planStatus in (:Statuses)" + " and b.active = 'Y'" + " and b.planId = plan.id" + " and load.systemId = b.systemId" + " and b.buildType = :BuildType" + " and b.loadSetType = :LoadSetType" + " and load.planId = plan.id");
	// This is Mutualy Exculsive, So ELSE
	if (pFilter != null && !pFilter.isEmpty()) {
	    lQuery.append(" AND plan.id LIKE :Planid");
	}
	if (isDelta) {
	    lQuery.append(" AND plan.id LIKE 'D%'");
	} else {
	    lQuery.append(" AND plan.id LIKE 'T%'");
	}
	lQuery.append(" group by plan.id");
	lQuery.append(" order by min(load.loadDateTime),1");

	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	Query mockedQry = mock(Query.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createQuery(lQuery.toString())).thenReturn(mockedQry);
	when(mockedQry.setParameterList("Statuses", planStatus)).thenReturn(mockedQry);
	when(mockedQry.setParameter("BuildType", Constants.BUILD_TYPE.STG_LOAD.name())).thenReturn(mockedQry);
	when(mockedQry.setParameter("LoadSetType", loadSetType)).thenReturn(mockedQry);
	when(mockedQry.setParameter("Planid" + "%", DataWareHouse.getPlan().getId() + "%")).thenReturn(mockedQry);
	when(mockedQry.setFirstResult(offset * limit)).thenReturn(mockedQry);
	when(mockedQry.setMaxResults(limit)).thenReturn(mockedQry);

	instance.findByLoad(planStatus, Constants.BUILD_TYPE.STG_LOAD.name(), isDelta, loadSetType, offset, limit, false);
    }

    @Test
    public void testGetCountOfLoad1() {
	List<String> planStatus = new ArrayList();
	planStatus.add(DataWareHouse.getPlan().getId());
	Boolean isDelta = false;
	String loadSetType = "E";
	String pFilter = DataWareHouse.getPlan().getId();
	StringBuilder lQuery = new StringBuilder("select count( DISTINCT plan.id) from imp_plan plan, build b, system_load load" + " where " + " plan.plan_status in (:Statuses)" + " and b.active = 'Y'" + " and b.plan_id = plan.id" + " and load.system_id = b.system_id" + " and b.build_type = :BuildType" + " and b.load_set_type = :LoadSetType" + " and load.plan_id = plan.id");

	String lAppendQuery = "";
	// This is Mutualy Exculsive, So ELSE
	if (pFilter != null && !pFilter.isEmpty()) {
	    lQuery.append(" AND plan.id LIKE :Planid");
	}
	if (isDelta) {
	    lQuery.append(" AND plan.id LIKE 'D%'");
	} else {
	    lQuery.append(" AND plan.id LIKE 'T%'");
	}

	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery.toString())).thenReturn(mockedQry);
	when(mockedQry.setParameterList("Statuses", planStatus)).thenReturn(mockedQry);
	when(mockedQry.setParameter("BuildType", Constants.BUILD_TYPE.STG_LOAD.name())).thenReturn(mockedQry);
	when(mockedQry.setParameter("LoadSetType", loadSetType)).thenReturn(mockedQry);
	when(mockedQry.setParameter("Planid" + "%", DataWareHouse.getPlan().getId() + "%")).thenReturn(mockedQry);

	instance.getCountOfLoad(planStatus, Constants.BUILD_TYPE.STG_LOAD.name(), isDelta, loadSetType);
    }

    @Test
    public void testFindQAPlanList() {
	List<String> status = new ArrayList();
	String pFilter = "test";
	Constants.BUILD_TYPE build_type = Constants.BUILD_TYPE.DVL_BUILD;
	Constants.LoaderTypes loaderTypes = Constants.LoaderTypes.A;
	List<String> qaFilter = new ArrayList();
	Integer offset = 0;
	Integer limit = 10;
	LinkedHashMap<String, String> lOrderBy = new LinkedHashMap();
	lOrderBy.put("id", "ASC");

	String lQueryString = "SELECT plan FROM ImpPlan plan, Build build, SystemLoad sysLoad" + " WHERE plan.id = build.planId " + " AND plan.active = 'Y'" + " AND plan.macroHeader = false" + " AND plan.planStatus in (:planStatus)" + " AND build.buildType = :buildType" + " AND build.loadSetType = :loadType" + " AND build.active ='Y'" + " AND build.jobStatus = 'S'" + " AND plan.id = sysLoad.planId " + " AND sysLoad.active = 'Y' " + " AND sysLoad.qaBypassStatus IN (:qaFilter) ";
	if (pFilter != null && !pFilter.isEmpty()) {
	    lQueryString = lQueryString + " AND plan.id LIKE '%" + pFilter + "%'";
	}
	String lOrderByString = "";

	if (lOrderBy != null && !lOrderBy.isEmpty()) {
	    for (Map.Entry<String, String> entrySet : lOrderBy.entrySet()) {
		String key = entrySet.getKey();
		String value = entrySet.getValue();
		lOrderByString = " ORDER BY plan." + key + " " + value;
	    }
	} else {
	    lQueryString = lQueryString + "GROUP BY plan ORDER BY MIN(sysLoad.loadDateTime)";
	}

	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createQuery(lQueryString + lOrderByString)).thenReturn(mockedQry);
	when(mockedQry.setParameterList(Matchers.any(), Matchers.anyCollection())).thenReturn(mockedQry);
	when(mockedQry.setParameter(Matchers.any(), Matchers.any())).thenReturn(mockedQry);
	when(mockedQry.setFirstResult(offset * limit)).thenReturn(mockedQry);
	when(mockedQry.setMaxResults(limit)).thenReturn(mockedQry);

	instance.findQAPlanList(status, pFilter, build_type, loaderTypes, qaFilter, offset, limit, lOrderBy);
    }

    @Test
    public void testCountByQAStatusList() {
	List<String> status = new ArrayList();
	String pFilter = "test";
	Constants.BUILD_TYPE build_type = Constants.BUILD_TYPE.DVL_BUILD;
	Constants.LoaderTypes loaderTypes = Constants.LoaderTypes.A;
	List<String> qaFilter = new ArrayList();

	String lQueryString = "SELECT count(DISTINCT plan) FROM ImpPlan plan, Build build, SystemLoad sysLoad " + " WHERE plan.id = build.planId " + " AND plan.active = 'Y'" + " AND plan.macroHeader = false" + " AND plan.planStatus in (:planStatus)" + " AND build.buildType = :buildType" + " AND build.loadSetType = :loadType" + " AND build.active ='Y'" + " AND build.jobStatus = 'S'" + " AND plan.id = sysLoad.planId " + " AND sysLoad.active = 'Y' " + " AND sysLoad.qaBypassStatus IN (:qaFilter) ";
	if (pFilter != null && !pFilter.isEmpty()) {
	    lQueryString = lQueryString + " AND plan.id LIKE '%" + pFilter + "%'";
	}

	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createQuery(lQueryString)).thenReturn(mockedQry);
	when(mockedQry.setParameterList(Matchers.any(), Matchers.anyCollection())).thenReturn(mockedQry);
	when(mockedQry.setParameter(Matchers.any(), Matchers.any())).thenReturn(mockedQry);

	instance.countByQAStatusList(status, pFilter, build_type, loaderTypes, qaFilter);
    }

    @Test
    public void testCountByQAStatusList1() {
	List<String> status = new ArrayList();
	String pFilter = null;
	Constants.BUILD_TYPE build_type = Constants.BUILD_TYPE.DVL_BUILD;
	Constants.LoaderTypes loaderTypes = Constants.LoaderTypes.A;
	List<String> qaFilter = new ArrayList();

	String lQueryString = "SELECT count(DISTINCT plan) FROM ImpPlan plan, Build build, SystemLoad sysLoad " + " WHERE plan.id = build.planId " + " AND plan.active = 'Y'" + " AND plan.macroHeader = false" + " AND plan.planStatus in (:planStatus)" + " AND build.buildType = :buildType" + " AND build.loadSetType = :loadType" + " AND build.active ='Y'" + " AND build.jobStatus = 'S'" + " AND plan.id = sysLoad.planId " + " AND sysLoad.active = 'Y' " + " AND sysLoad.qaBypassStatus IN (:qaFilter) ";
	if (pFilter != null && !pFilter.isEmpty()) {
	    lQueryString = lQueryString + " AND plan.id LIKE '%" + pFilter + "%'";
	}

	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createQuery(lQueryString)).thenReturn(mockedQry);
	when(mockedQry.setParameterList(Matchers.any(), Matchers.anyCollection())).thenReturn(mockedQry);
	when(mockedQry.setParameter(Matchers.any(), Matchers.any())).thenReturn(mockedQry);

	instance.countByQAStatusList(status, pFilter, build_type, loaderTypes, qaFilter);
    }

    @Test
    public void testGetCountOfAdvancedSearch1() {
	AdvancedSearchForm searchForm = new AdvancedSearchForm();
	StringBuilder lBuilder = new StringBuilder();
	lBuilder.append("SELECT COUNT(DISTINCT (lPlan.id,lSystem.name)) ");
	lBuilder.append(" FROM system_load lSystemLoads LEFT JOIN production_loads lProdLoads ON lSystemLoads.plan_id=lProdLoads.plan_id ");
	lBuilder.append(" LEFT JOIN dbcr dbcr ON lSystemLoads.plan_id=dbcr.plan_id,");
	lBuilder.append("  system lSystem,checkout_segments lSegments, implementation lImpl, imp_plan lPlan,load_categories lc,project lproj");
	lBuilder.append(" WHERE lSystemLoads.load_date_time between :activatedStartTime AND :activatedEndTime");

	searchForm.setTargetSystems(DataWareHouse.getSystemList());
	if (searchForm.getTargetSystems().size() > 0) {
	    lBuilder.append(" AND lSystem.id IN (:systemId)");
	}

	searchForm.setProgramName("test");
	if (searchForm.getProgramName() != null) {
	    lBuilder.append(" AND lSegments.plan_id in (SELECT plan_id from checkout_segments where LOWER(program_name) like :programName)");
	}

	searchForm.setCsrNumber(Arrays.asList("test"));
	if (searchForm.getCsrNumber() != null && !searchForm.getCsrNumber().isEmpty()) {
	    lBuilder.append(" AND lproj.project_number IN (:csrNumber) ");
	}
	searchForm.setImplPlanStatus(Arrays.asList("Test"));
	if (searchForm.getImplPlanStatus() != null && !searchForm.getImplPlanStatus().isEmpty()) {
	    lBuilder.append(" AND lPlan.plan_status IN (:planStatus) ");
	}
	searchForm.setFunctionalPackages(Arrays.asList("Test"));
	if (searchForm.getFunctionalPackages() != null && !searchForm.getFunctionalPackages().isEmpty()) {
	    lBuilder.append(" AND lSegments.func_area IN (:functionalArea) ");
	}
	List<String> lList = Constants.UserGroup.getKeyMappingGroupList();
	searchForm.setRole(lList);
	List<String> roleList = searchForm.getRole();
	if (roleList != null && roleList.size() > 0) {
	    boolean setFlag = false;
	    lBuilder.append("  AND ( ");
	    String logicalOperator = " OR ";

	    if (roleList.contains(Constants.UserGroup.Lead.name())) {

		lBuilder.append("  lPlan.lead_id = :developerLead ");
		setFlag = true;
	    }
	    if (roleList.contains(Constants.UserGroup.Developer.name())) {
		if (setFlag) {
		    lBuilder.append(logicalOperator);
		} else {
		    setFlag = true;
		}
		lBuilder.append("  lImpl.dev_id = :developer");
	    }
	    if (roleList.contains(Constants.UserGroup.Reviewer.name())) {
		if (setFlag) {
		    lBuilder.append(logicalOperator);
		} else {
		    setFlag = true;
		}
		lBuilder.append("  lImpl.peer_reviewers = :reviewer");
	    }
	    if (roleList.contains(Constants.UserGroup.LoadsControl.name())) {
		if (setFlag) {
		    lBuilder.append(logicalOperator);
		} else {
		    setFlag = true;
		}
		lBuilder.append("  lSystemLoads.load_attendee_id = :loadAttendee");
	    }
	    if (roleList.contains(Constants.UserGroup.DevManager.name())) {
		if (setFlag) {
		    lBuilder.append(logicalOperator);
		} else {
		    setFlag = true;
		}
		lBuilder.append("  lPlan.dev_manager = :devManager");
	    }
	    lBuilder.append(" ) ");
	}

	lBuilder.append(" AND lSegments.plan_id =  lSystemLoads.plan_id");

	lBuilder.append(" AND lImpl.active = 'Y'");
	lBuilder.append(" AND lPlan.active = 'Y'");
	lBuilder.append(" AND lSystemLoads.active = 'Y'");
	lBuilder.append(" AND lSegments.active = 'Y'");

	lBuilder.append(" AND lSystem.id = lSystemLoads.system_id ");
	lBuilder.append(" AND lSegments.target_system = lSystem.name");
	lBuilder.append(" AND lPlan.id = lSystemLoads.plan_id  ");
	lBuilder.append(" AND lImpl.plan_id = lSystemLoads.plan_id ");
	lBuilder.append(" AND  lImpl.id = lSegments.imp_id ");
	lBuilder.append(" AND lc.id = lSystemLoads.load_category_id ");
	lBuilder.append(" AND lproj.id = lPlan.project_id ");
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lBuilder.toString())).thenReturn(mockedQry);
	when(mockedQry.setParameterList(Matchers.any(), Matchers.anyCollection())).thenReturn(mockedQry);
	when(mockedQry.setParameter(Matchers.any(), Matchers.any())).thenReturn(mockedQry);

    }

    @Test
    public void testfindByStatusOnLoadTypeList() {

	ReflectionTestUtils.setField(instance, "sessionFactory", Mockito.mock(SessionFactory.class));

	Session session = Mockito.mock(Session.class);
	Criteria mockedCriteria = Mockito.mock(Criteria.class);
	Mockito.when(instance.getSessionFactory().getCurrentSession()).thenReturn(session);
	Mockito.when(instance.getDAOClass()).thenReturn(ImpPlanDAO.class);
	Mockito.when(session.createCriteria(ImpPlanDAO.class)).thenReturn(mockedCriteria);
	LinkedHashMap<String, String> lOrderBy = new LinkedHashMap<String, String>();
	lOrderBy.put("id", "asc");
	instance.findByStatusOnLoadTypeList("APPROVED", Constants.LoadTypes.EXCEPTION.name(), 1, 5, lOrderBy);
    }

    @Test
    public void tesgetImpPlanFromLoadDateTime() {
	SessionFactory sessionFactory = mock(SessionFactory.class);
	ReflectionTestUtils.setField(instance, "sessionFactory", sessionFactory);
	Session session = mock(Session.class);
	SQLQuery mockedQry = mock(SQLQuery.class);

	List<Object[]> lPlanList = mock(List.class);

	String lQuery = "SELECT impPlan.id,impPlan.lead_id,impPlan.dev_manager,sysLoad.load_date_time, string_agg(sys.name, ', ') AS name,imp.peer_reviewers,imp.dev_id" + " FROM imp_plan impPlan, system_load sysLoad ,system sys,implementation imp, build c " + " WHERE impPlan.plan_status IN (:planStatus) " + " AND date(sysLoad.load_date_time) = date (now()+ INTERVAL '4 days')  " + " AND sysLoad.prod_load_status is null" + " AND sysLoad.active = 'Y'" + " AND impPlan.active = 'Y'"
		+ " AND c.system_id = sysLoad.system_id" + " AND c.plan_id = impPlan.id" + " AND c.build_type = '" + Constants.BUILD_TYPE.STG_LOAD.name() + "'" + " AND c.load_set_type = '" + Constants.LoaderTypes.E + "'" + " AND sysLoad.plan_id = impPlan.id " + " AND sys.id=sysLoad.system_id" + " AND imp.plan_id=impPlan.id " + " GROUP BY  impPlan.id,sysLoad.load_date_time,imp.peer_reviewers,imp.dev_id " + " ORDER BY impPlan.id DESC";
	Date now = new Date();
	List<String> status = new ArrayList<>();
	status.add(DataWareHouse.getPlan().getPlanStatus());
	when(sessionFactory.getCurrentSession()).thenReturn(session);
	when(session.createSQLQuery(lQuery)).thenReturn(mockedQry);
	when(mockedQry.setParameterList("planStatus", status)).thenReturn(mockedQry);
	when(instance.getImpPlanFromLoadDateTime(status)).thenReturn(lPlanList);

    }
}
