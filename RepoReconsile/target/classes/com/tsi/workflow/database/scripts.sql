create table <schema>.repo_detail(id serial PRIMARY KEY, source_repo text, derived_repo text, func_area text, file_type text, company text);
create table <schema>.sub_repo_detail(id serial PRIMARY KEY, repo_id integer, sub_source_repo text, sub_derived_repo text, source_url text, derived_url text);
create table <schema>.repo_file_list(id serial PRIMARY KEY, sub_repo_id integer, file_name text, program_name text, file_ext text, target_system text, is_deleted varchar(1) default 'N');
create table <schema>.repo_commit(id serial PRIMARY KEY, sub_repo_id integer, file_id integer, source_commit_id text, derived_commit_id text, committer_name text, committer_mail_id text, commit_date_time timestamp without time zone, ref_plan text, ref_status text, ref_load_date_time timestamp without time zone, file_hashcode text);
ALTER TABLE ONLY <schema>.sub_repo_detail ADD CONSTRAINT repo_detail_id_fkey FOREIGN KEY (repo_id) REFERENCES <schema>.repo_detail(id);
ALTER TABLE ONLY <schema>.repo_file_list ADD CONSTRAINT sub_repo_detail_id_fkey FOREIGN KEY (sub_repo_id) REFERENCES <schema>.sub_repo_detail(id);
ALTER TABLE ONLY <schema>.repo_commit ADD CONSTRAINT sub_repo_id_fkey FOREIGN KEY (sub_repo_id) REFERENCES <schema>.sub_repo_detail(id);
ALTER TABLE ONLY <schema>.repo_commit ADD CONSTRAINT file_id_fkey FOREIGN KEY (file_id) REFERENCES <schema>.repo_file_list(id);
CREATE OR REPLACE VIEW <schema>_PROD_SEARCH_DB AS SELECT a.id AS repo_commit_id, d.func_area, rank() OVER(partition BY a.file_id, a.ref_status ORDER BY a.ref_load_date_time DESC) as version, a.sub_repo_id, a.file_id, b.file_name, b.program_name, a.source_commit_id, a.derived_commit_id, a.committer_name, a.committer_mail_id, a.commit_date_time, a.ref_plan, a.ref_status, a.ref_load_date_time, a.file_hashcode, LOWER('master_'||b.target_system) as target_system, c.repo_id, c.sub_source_repo, c.sub_derived_repo, c.source_url, c.derived_url, d.source_repo, d.derived_repo, d.company, d.file_type, b.file_ext, case when c.repo_id>0 then 'Y' else 'N' end as active FROM   <schema>.repo_commit a, <schema>.repo_file_list b, <schema>.sub_repo_detail c, <schema>.repo_detail d WHERE  a.file_id = b.id AND b.sub_repo_id = c.id AND c.repo_id = d.id AND a.id IN (SELECT DISTINCT F.id FROM   (SELECT c.id, C.delete_id, c.file_id, Rank() OVER ( partition BY c.file_id ORDER BY c.id DESC) AS load_date_rank FROM   (SELECT a.id, a.file_id, a.source_commit_id, a.ref_load_date_time, CASE WHEN ( b.id > 0 ) THEN B.id ELSE 0 END AS DELETE_ID FROM   (SELECT id, file_id, source_commit_id, ref_load_date_time FROM   <schema>.repo_commit WHERE  ref_status = 'Online') a LEFT JOIN (SELECT file_id, Max(id) AS id FROM   <schema>.repo_commit WHERE ref_status = 'Deleted' GROUP  BY file_id) b ON a.file_id = b.file_id) c WHERE  c.id > C.delete_id) F WHERE  F.load_date_rank <= 3 UNION ALL SELECT DISTINCT G.id FROM   (SELECT c.id, C.delete_id, c.file_id, Rank() OVER ( partition BY c.file_id ORDER BY c.id DESC) AS load_date_rank FROM   (SELECT a.id, a.file_id, a.source_commit_id, a.ref_load_date_time, CASE WHEN ( b.id > 0 ) THEN B.id ELSE 0 END AS DELETE_ID FROM   (SELECT id, file_id, source_commit_id, ref_load_date_time FROM   <schema>.repo_commit WHERE  ref_status = 'Fallback') a LEFT JOIN (SELECT file_id, Max(id) AS id FROM   <schema>.repo_commit WHERE ref_status = 'Deleted' GROUP  BY file_id) b ON a.file_id = b.file_id) c WHERE  c.id > C.delete_id) G WHERE  G.load_date_rank = 1 UNION ALL SELECT DISTINCT H.id FROM   (SELECT c.id, C.delete_id, c.file_id FROM   (SELECT a.id, a.file_id, a.source_commit_id, a.ref_load_date_time, CASE WHEN ( b.id > 0 ) THEN B.id ELSE 0 END AS DELETE_ID FROM   (SELECT id, file_id, source_commit_id, ref_load_date_time FROM   <schema>.repo_commit WHERE  ref_status = 'Pending') a LEFT JOIN (SELECT file_id, Max(id) AS id FROM   <schema>.repo_commit WHERE ref_status = 'Deleted' GROUP  BY file_id) b ON a.file_id = b.file_id) c WHERE  c.id > C.delete_id) H) order by b.file_name,a.ref_status,a.ref_load_date_time
create table <schema>.user_details(id serial primary key, user_name text, repo_id integer, permission text);
ALTER TABLE ONLY <schema>.user_details ADD CONSTRAINT repo_detail_id_fkey FOREIGN KEY (repo_id) REFERENCES <schema>.repo_detail(id);
ALTER TABLE <schema>.repo_detail ADD COLUMN default_permission TEXT;
create table <schema>.users(id serial primary key, user_name text, display_name text, active text);
ALTER TABLE <schema>.repo_detail  ADD COLUMN repo_description text;
ALTER TABLE <schema>.sub_repo_detail ADD COLUMN target_systems character varying;
ALTER TABLE <schema>.repo_commit ADD COLUMN created_dt timestamp without time zone;
ALTER TABLE <schema>.repo_commit ADD COLUMN modified_dt timestamp without time zone;
ALTER TABLE <schema>.repo_detail ADD COLUMN created_dt timestamp without time zone;
ALTER TABLE <schema>.repo_detail ADD COLUMN modified_dt timestamp without time zone;
ALTER TABLE <schema>.sub_repo_detail ADD COLUMN created_dt timestamp without time zone;
ALTER TABLE <schema>.sub_repo_detail ADD COLUMN modified_dt timestamp without time zone;
ALTER TABLE <schema>.repo_file_list ADD COLUMN created_dt timestamp without time zone;
ALTER TABLE <schema>.repo_file_list ADD COLUMN modified_dt timestamp without time zone;
ALTER TABLE <schema>.user_details ADD COLUMN created_dt timestamp without time zone;
ALTER TABLE <schema>.user_details ADD COLUMN modified_dt timestamp without time zone;
GRANT ALL ON SEQUENCE <schema>.repo_commit_id_seq TO public;
GRANT ALL ON SEQUENCE <schema>.repo_detail_id_seq TO public;
GRANT ALL ON SEQUENCE <schema>.repo_file_list_id_seq TO public;
GRANT ALL ON SEQUENCE <schema>.sub_repo_detail_id_seq TO public;
GRANT ALL ON TABLE <schema>.repo_commit TO public;
GRANT ALL ON TABLE <schema>.repo_detail TO public;
GRANT ALL ON TABLE <schema>.repo_file_list TO public;
GRANT ALL ON TABLE <schema>.sub_repo_detail TO public;
GRANT ALL ON TABLE <schema>.users TO public;
GRANT ALL ON SEQUENCE <schema>.users_id_seq TO public;
GRANT ALL ON SEQUENCE <schema>.user_details_id_seq TO public;
GRANT ALL ON TABLE <schema>.user_details TO public;
GRANT ALL ON TABLE public.<schema>_prod_search_db TO postgres;
GRANT ALL ON TABLE public.<schema>_prod_search_db TO public;